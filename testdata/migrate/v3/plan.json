{
  "version": "1.0.0",
  "pgschema_version": "0.3.0",
  "created_at": "2025-08-06T00:06:32+08:00",
  "transaction": true,
  "summary": {
    "total": 3,
    "add": 2,
    "change": 1,
    "destroy": 0,
    "by_type": {
      "functions": {
        "add": 1,
        "change": 0,
        "destroy": 0
      },
      "tables": {
        "add": 1,
        "change": 1,
        "destroy": 0
      }
    }
  },
  "diffs": [
    {
      "sql": "CREATE TABLE IF NOT EXISTS audit (\n    id SERIAL PRIMARY KEY,\n    operation text NOT NULL,\n    query text,\n    user_name text NOT NULL,\n    changed_at timestamptz DEFAULT CURRENT_TIMESTAMP\n);",
      "type": "table",
      "operation": "create",
      "path": "public.audit",
      "source": {
        "schema": "public",
        "name": "audit",
        "type": "BASE_TABLE",
        "columns": [
          {
            "name": "id",
            "position": 1,
            "data_type": "integer",
            "is_nullable": false,
            "default_value": "nextval('audit_id_seq'::regclass)"
          },
          {
            "name": "operation",
            "position": 2,
            "data_type": "text",
            "is_nullable": false
          },
          {
            "name": "query",
            "position": 3,
            "data_type": "text",
            "is_nullable": true
          },
          {
            "name": "user_name",
            "position": 4,
            "data_type": "text",
            "is_nullable": false
          },
          {
            "name": "changed_at",
            "position": 5,
            "data_type": "timestamptz",
            "is_nullable": true,
            "default_value": "CURRENT_TIMESTAMP"
          }
        ],
        "constraints": {
          "audit_pkey": {
            "schema": "public",
            "table": "audit",
            "name": "audit_pkey",
            "type": "PRIMARY_KEY",
            "columns": [
              {
                "name": "id",
                "position": 1
              }
            ]
          }
        },
        "indexes": {
          "idx_audit_changed_at": {
            "schema": "public",
            "table": "audit",
            "name": "idx_audit_changed_at",
            "type": "REGULAR",
            "method": "btree",
            "columns": [
              {
                "name": "changed_at",
                "position": 1,
                "direction": "ASC"
              }
            ],
            "is_concurrent": false,
            "is_partial": false,
            "is_expression": false
          }
        },
        "triggers": {},
        "rls_enabled": false,
        "policies": {},
        "dependencies": null,
        "is_partitioned": false
      },
      "can_run_in_transaction": true
    },
    {
      "sql": "CREATE INDEX IF NOT EXISTS idx_audit_changed_at ON audit (changed_at);",
      "type": "table.index",
      "operation": "create",
      "path": "public.audit.idx_audit_changed_at",
      "source": {
        "schema": "public",
        "table": "audit",
        "name": "idx_audit_changed_at",
        "type": "REGULAR",
        "method": "btree",
        "columns": [
          {
            "name": "changed_at",
            "position": 1,
            "direction": "ASC"
          }
        ],
        "is_concurrent": false,
        "is_partial": false,
        "is_expression": false
      },
      "can_run_in_transaction": true
    },
    {
      "sql": "CREATE OR REPLACE FUNCTION log_dml_operations()\nRETURNS trigger\nLANGUAGE plpgsql\nSECURITY INVOKER\nVOLATILE\nAS $$\nBEGIN\n    IF (TG_OP = 'INSERT') THEN\n        INSERT INTO audit (operation, query, user_name)\n        VALUES ('INSERT', current_query(), current_user);\n        RETURN NEW;\n    ELSIF (TG_OP = 'UPDATE') THEN\n        INSERT INTO audit (operation, query, user_name)\n        VALUES ('UPDATE', current_query(), current_user);\n        RETURN NEW;\n    ELSIF (TG_OP = 'DELETE') THEN\n        INSERT INTO audit (operation, query, user_name)\n        VALUES ('DELETE', current_query(), current_user);\n        RETURN OLD;\n    END IF;\n    RETURN NULL;\nEND;\n$$;",
      "type": "function",
      "operation": "create",
      "path": "public.log_dml_operations",
      "source": {
        "schema": "public",
        "name": "log_dml_operations",
        "definition": "\nBEGIN\n    IF (TG_OP = 'INSERT') THEN\n        INSERT INTO audit (operation, query, user_name)\n        VALUES ('INSERT', current_query(), current_user);\n        RETURN NEW;\n    ELSIF (TG_OP = 'UPDATE') THEN\n        INSERT INTO audit (operation, query, user_name)\n        VALUES ('UPDATE', current_query(), current_user);\n        RETURN NEW;\n    ELSIF (TG_OP = 'DELETE') THEN\n        INSERT INTO audit (operation, query, user_name)\n        VALUES ('DELETE', current_query(), current_user);\n        RETURN OLD;\n    END IF;\n    RETURN NULL;\nEND;\n",
        "return_type": "trigger",
        "language": "plpgsql",
        "volatility": "VOLATILE"
      },
      "can_run_in_transaction": true
    },
    {
      "sql": "CREATE OR REPLACE TRIGGER salary_log_trigger\n    AFTER UPDATE OR DELETE ON salary\n    FOR EACH ROW\n    EXECUTE FUNCTION log_dml_operations();",
      "type": "table.trigger",
      "operation": "create",
      "path": "public.salary.salary_log_trigger",
      "source": {
        "schema": "public",
        "table": "salary",
        "name": "salary_log_trigger",
        "timing": "AFTER",
        "events": [
          "UPDATE",
          "DELETE"
        ],
        "level": "ROW",
        "function": "log_dml_operations()"
      },
      "can_run_in_transaction": true
    }
  ]
}