// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package queries

import (
	"context"
)

const getColumns = `-- name: GetColumns :many
SELECT 
    c.table_schema,
    c.table_name,
    c.column_name,
    c.ordinal_position,
    c.column_default,
    c.is_nullable,
    c.data_type,
    c.character_maximum_length,
    c.numeric_precision,
    c.numeric_scale,
    c.udt_name,
    d.description AS column_comment
FROM information_schema.columns c
LEFT JOIN pg_class cl ON cl.relname = c.table_name
LEFT JOIN pg_namespace n ON cl.relnamespace = n.oid AND n.nspname = c.table_schema
LEFT JOIN pg_description d ON d.objoid = cl.oid AND d.classoid = 'pg_class'::regclass AND d.objsubid = c.ordinal_position
WHERE 
    c.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND c.table_schema NOT LIKE 'pg_temp_%'
    AND c.table_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY c.table_schema, c.table_name, c.ordinal_position
`

type GetColumnsRow struct {
	TableSchema            interface{}
	TableName              interface{}
	ColumnName             interface{}
	OrdinalPosition        interface{}
	ColumnDefault          interface{}
	IsNullable             interface{}
	DataType               interface{}
	CharacterMaximumLength interface{}
	NumericPrecision       interface{}
	NumericScale           interface{}
	UdtName                interface{}
	ColumnComment          interface{}
}

// GetColumns retrieves all columns for all tables
func (q *Queries) GetColumns(ctx context.Context) ([]GetColumnsRow, error) {
	rows, err := q.db.QueryContext(ctx, getColumns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetColumnsRow
	for rows.Next() {
		var i GetColumnsRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.ColumnName,
			&i.OrdinalPosition,
			&i.ColumnDefault,
			&i.IsNullable,
			&i.DataType,
			&i.CharacterMaximumLength,
			&i.NumericPrecision,
			&i.NumericScale,
			&i.UdtName,
			&i.ColumnComment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConstraints = `-- name: GetConstraints :many
SELECT 
    n.nspname AS table_schema,
    cl.relname AS table_name,
    c.conname AS constraint_name,
    CASE c.contype
        WHEN 'c' THEN 'CHECK'
        WHEN 'f' THEN 'FOREIGN KEY'
        WHEN 'p' THEN 'PRIMARY KEY'
        WHEN 'u' THEN 'UNIQUE'
        WHEN 'x' THEN 'EXCLUDE'
        ELSE 'UNKNOWN'
    END AS constraint_type,
    a.attname AS column_name,
    a.attnum AS ordinal_position,
    fn.nspname AS foreign_table_schema,
    fcl.relname AS foreign_table_name,
    fa.attname AS foreign_column_name,
    fa.attnum AS foreign_ordinal_position,
    CASE WHEN c.contype = 'c' THEN pg_get_constraintdef(c.oid) ELSE NULL END AS check_clause,
    CASE c.confdeltype
        WHEN 'a' THEN 'NO ACTION'
        WHEN 'r' THEN 'RESTRICT'
        WHEN 'c' THEN 'CASCADE'
        WHEN 'n' THEN 'SET NULL'
        WHEN 'd' THEN 'SET DEFAULT'
        ELSE NULL
    END AS delete_rule,
    CASE c.confupdtype
        WHEN 'a' THEN 'NO ACTION'
        WHEN 'r' THEN 'RESTRICT'
        WHEN 'c' THEN 'CASCADE'
        WHEN 'n' THEN 'SET NULL'
        WHEN 'd' THEN 'SET DEFAULT'
        ELSE NULL
    END AS update_rule,
    c.condeferrable AS deferrable,
    c.condeferred AS initially_deferred
FROM pg_constraint c
JOIN pg_class cl ON c.conrelid = cl.oid
JOIN pg_namespace n ON cl.relnamespace = n.oid
LEFT JOIN pg_attribute a ON a.attrelid = c.conrelid AND a.attnum = ANY(c.conkey)
LEFT JOIN pg_class fcl ON c.confrelid = fcl.oid
LEFT JOIN pg_namespace fn ON fcl.relnamespace = fn.oid
LEFT JOIN pg_attribute fa ON fa.attrelid = c.confrelid AND fa.attnum = c.confkey[array_position(c.conkey, a.attnum)]
WHERE n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
ORDER BY n.nspname, cl.relname, c.contype, c.conname, a.attnum
`

type GetConstraintsRow struct {
	TableSchema          interface{}
	TableName            interface{}
	ConstraintName       interface{}
	ConstraintType       interface{}
	ColumnName           interface{}
	OrdinalPosition      interface{}
	ForeignTableSchema   interface{}
	ForeignTableName     interface{}
	ForeignColumnName    interface{}
	ForeignOrdinalPosition interface{}
	CheckClause          interface{}
	DeleteRule           interface{}
	UpdateRule           interface{}
	Deferrable           interface{}
	InitiallyDeferred    interface{}
}

// GetConstraints retrieves all table constraints
func (q *Queries) GetConstraints(ctx context.Context) ([]GetConstraintsRow, error) {
	rows, err := q.db.QueryContext(ctx, getConstraints)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConstraintsRow
	for rows.Next() {
		var i GetConstraintsRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.ConstraintName,
			&i.ConstraintType,
			&i.ColumnName,
			&i.OrdinalPosition,
			&i.ForeignTableSchema,
			&i.ForeignTableName,
			&i.ForeignColumnName,
			&i.ForeignOrdinalPosition,
			&i.CheckClause,
			&i.DeleteRule,
			&i.UpdateRule,
			&i.Deferrable,
			&i.InitiallyDeferred,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExtensions = `-- name: GetExtensions :many
SELECT 
    n.nspname AS schema_name,
    e.extname AS extension_name,
    e.extversion AS extension_version,
    d.description AS extension_comment
FROM pg_extension e
JOIN pg_namespace n ON e.extnamespace = n.oid
LEFT JOIN pg_description d ON d.objoid = e.oid AND d.classoid = 'pg_extension'::regclass
WHERE n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
ORDER BY e.extname
`

type GetExtensionsRow struct {
	SchemaName       string
	ExtensionName    string
	ExtensionVersion string
	ExtensionComment interface{}
}

// GetExtensions retrieves all extensions
func (q *Queries) GetExtensions(ctx context.Context) ([]GetExtensionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getExtensions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExtensionsRow
	for rows.Next() {
		var i GetExtensionsRow
		if err := rows.Scan(&i.SchemaName, &i.ExtensionName, &i.ExtensionVersion, &i.ExtensionComment); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFunctions = `-- name: GetFunctions :many
SELECT 
    r.routine_schema,
    r.routine_name,
    r.routine_definition,
    r.routine_type,
    COALESCE(pg_get_function_result(p.oid), r.data_type) AS data_type,
    r.external_language,
    desc_func.description AS function_comment,
    oidvectortypes(p.proargtypes) AS function_arguments,
    pg_get_function_arguments(p.oid) AS function_signature,
    CASE p.provolatile
        WHEN 'i' THEN 'IMMUTABLE'
        WHEN 's' THEN 'STABLE'
        WHEN 'v' THEN 'VOLATILE'
        ELSE NULL
    END AS volatility,
    p.proisstrict AS is_strict
FROM information_schema.routines r
LEFT JOIN pg_proc p ON p.proname = r.routine_name 
    AND p.pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = r.routine_schema)
LEFT JOIN pg_depend d ON d.objid = p.oid AND d.deptype = 'e'
LEFT JOIN pg_description desc_func ON desc_func.objoid = p.oid AND desc_func.classoid = 'pg_proc'::regclass
WHERE 
    r.routine_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND r.routine_schema NOT LIKE 'pg_temp_%'
    AND r.routine_schema NOT LIKE 'pg_toast_temp_%'
    AND r.routine_type = 'FUNCTION'
    AND d.objid IS NULL  -- Exclude functions that are extension members
ORDER BY r.routine_schema, r.routine_name
`

type GetFunctionsRow struct {
	RoutineSchema      interface{}
	RoutineName        interface{}
	RoutineDefinition  interface{}
	RoutineType        interface{}
	DataType           interface{}
	ExternalLanguage   interface{}
	FunctionComment    interface{}
	FunctionArguments  interface{}
	FunctionSignature  interface{}
	Volatility         interface{}
	IsStrict           interface{}
}

// GetFunctions retrieves all user-defined functions (excluding extension members)
func (q *Queries) GetFunctions(ctx context.Context) ([]GetFunctionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFunctions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFunctionsRow
	for rows.Next() {
		var i GetFunctionsRow
		if err := rows.Scan(
			&i.RoutineSchema,
			&i.RoutineName,
			&i.RoutineDefinition,
			&i.RoutineType,
			&i.DataType,
			&i.ExternalLanguage,
			&i.FunctionComment,
			&i.FunctionArguments,
			&i.FunctionSignature,
			&i.Volatility,
			&i.IsStrict,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcedures = `-- GetProcedures retrieves all user-defined procedures (excluding extension members)
-- name: GetProcedures :many
SELECT 
    r.routine_schema,
    r.routine_name,
    r.routine_definition,
    r.routine_type,
    r.external_language,
    desc_proc.description AS procedure_comment,
    oidvectortypes(p.proargtypes) AS procedure_arguments,
    pg_get_function_arguments(p.oid) AS procedure_signature
FROM information_schema.routines r
LEFT JOIN pg_proc p ON p.proname = r.routine_name 
    AND p.pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = r.routine_schema)
LEFT JOIN pg_depend d ON d.objid = p.oid AND d.deptype = 'e'
LEFT JOIN pg_description desc_proc ON desc_proc.objoid = p.oid AND desc_proc.classoid = 'pg_proc'::regclass
WHERE 
    r.routine_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND r.routine_schema NOT LIKE 'pg_temp_%'
    AND r.routine_schema NOT LIKE 'pg_toast_temp_%'
    AND r.routine_type = 'PROCEDURE'
    AND d.objid IS NULL  -- Exclude procedures that are extension members
ORDER BY r.routine_schema, r.routine_name
`

type GetProceduresRow struct {
	RoutineSchema        interface{}
	RoutineName          interface{}
	RoutineDefinition    interface{}
	RoutineType          interface{}
	ExternalLanguage     interface{}
	ProcedureComment     interface{}
	ProcedureArguments   interface{}
	ProcedureSignature   interface{}
}

// GetProcedures retrieves all user-defined procedures (excluding extension members)
func (q *Queries) GetProcedures(ctx context.Context) ([]GetProceduresRow, error) {
	rows, err := q.db.QueryContext(ctx, getProcedures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProceduresRow
	for rows.Next() {
		var i GetProceduresRow
		if err := rows.Scan(
			&i.RoutineSchema,
			&i.RoutineName,
			&i.RoutineDefinition,
			&i.RoutineType,
			&i.ExternalLanguage,
			&i.ProcedureComment,
			&i.ProcedureArguments,
			&i.ProcedureSignature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAggregates = `-- GetAggregates retrieves all user-defined aggregates
-- name: GetAggregates :many
SELECT 
    n.nspname AS aggregate_schema,
    p.proname AS aggregate_name,
    pg_get_function_arguments(p.oid) AS aggregate_signature,
    oidvectortypes(p.proargtypes) AS aggregate_arguments,
    format_type(p.prorettype, NULL) AS aggregate_return_type,
    -- Get transition function
    tf.proname AS transition_function,
    tfn.nspname AS transition_function_schema,
    -- Get state type
    format_type(a.aggtranstype, NULL) AS state_type,
    -- Get initial condition
    a.agginitval AS initial_condition,
    -- Get final function if exists
    ff.proname AS final_function,
    ffn.nspname AS final_function_schema,
    -- Comment
    d.description AS aggregate_comment
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
JOIN pg_aggregate a ON a.aggfnoid = p.oid
LEFT JOIN pg_proc tf ON a.aggtransfn = tf.oid
LEFT JOIN pg_namespace tfn ON tf.pronamespace = tfn.oid
LEFT JOIN pg_proc ff ON a.aggfinalfn = ff.oid
LEFT JOIN pg_namespace ffn ON ff.pronamespace = ffn.oid
LEFT JOIN pg_description d ON d.objoid = p.oid AND d.classoid = 'pg_proc'::regclass
WHERE p.prokind = 'a'  -- Only aggregates
    AND n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
    AND NOT EXISTS (
        SELECT 1 FROM pg_depend dep 
        WHERE dep.objid = p.oid AND dep.deptype = 'e'
    )  -- Exclude extension members
ORDER BY n.nspname, p.proname
`

type GetAggregatesRow struct {
	AggregateSchema            interface{}
	AggregateName              interface{}
	AggregateSignature         interface{}
	AggregateArguments         interface{}
	AggregateReturnType        interface{}
	TransitionFunction         interface{}
	TransitionFunctionSchema   interface{}
	StateType                  interface{}
	InitialCondition           interface{}
	FinalFunction              interface{}
	FinalFunctionSchema        interface{}
	AggregateComment           interface{}
}

// GetAggregates retrieves all user-defined aggregates
func (q *Queries) GetAggregates(ctx context.Context) ([]GetAggregatesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAggregates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAggregatesRow
	for rows.Next() {
		var i GetAggregatesRow
		if err := rows.Scan(
			&i.AggregateSchema,
			&i.AggregateName,
			&i.AggregateSignature,
			&i.AggregateArguments,
			&i.AggregateReturnType,
			&i.TransitionFunction,
			&i.TransitionFunctionSchema,
			&i.StateType,
			&i.InitialCondition,
			&i.FinalFunction,
			&i.FinalFunctionSchema,
			&i.AggregateComment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndexes = `-- name: GetIndexes :many
SELECT 
    tc.table_schema as schemaname,
    tc.table_name as tablename,
    tc.constraint_name as indexname,
    'INDEX' as indextype
FROM information_schema.table_constraints tc
WHERE 
    tc.constraint_type IN ('PRIMARY KEY', 'UNIQUE')
    AND tc.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND tc.table_schema NOT LIKE 'pg_temp_%'
    AND tc.table_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY tc.table_schema, tc.table_name, tc.constraint_name
`

type GetIndexesRow struct {
	Schemaname interface{}
	Tablename  interface{}
	Indexname  interface{}
	Indextype  string
}

// GetIndexes retrieves all indexes (simplified for sqlc compatibility)
func (q *Queries) GetIndexes(ctx context.Context) ([]GetIndexesRow, error) {
	rows, err := q.db.QueryContext(ctx, getIndexes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIndexesRow
	for rows.Next() {
		var i GetIndexesRow
		if err := rows.Scan(
			&i.Schemaname,
			&i.Tablename,
			&i.Indexname,
			&i.Indextype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchemas = `-- name: GetSchemas :many
SELECT 
    schema_name
FROM information_schema.schemata
WHERE 
    schema_name NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND schema_name NOT LIKE 'pg_temp_%'
    AND schema_name NOT LIKE 'pg_toast_temp_%'
ORDER BY schema_name
`

// GetSchemas retrieves all user-defined schemas
func (q *Queries) GetSchemas(ctx context.Context) ([]interface{}, error) {
	rows, err := q.db.QueryContext(ctx, getSchemas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var schema_name interface{}
		if err := rows.Scan(&schema_name); err != nil {
			return nil, err
		}
		items = append(items, schema_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSequences = `-- name: GetSequences :many
SELECT 
    sequence_schema,
    sequence_name,
    data_type,
    start_value,
    minimum_value,
    maximum_value,
    increment,
    cycle_option
FROM information_schema.sequences
WHERE 
    sequence_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND sequence_schema NOT LIKE 'pg_temp_%'
    AND sequence_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY sequence_schema, sequence_name
`

type GetSequencesRow struct {
	SequenceSchema interface{}
	SequenceName   interface{}
	DataType       interface{}
	StartValue     interface{}
	MinimumValue   interface{}
	MaximumValue   interface{}
	Increment      interface{}
	CycleOption    interface{}
}

// GetSequences retrieves all sequences
func (q *Queries) GetSequences(ctx context.Context) ([]GetSequencesRow, error) {
	rows, err := q.db.QueryContext(ctx, getSequences)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSequencesRow
	for rows.Next() {
		var i GetSequencesRow
		if err := rows.Scan(
			&i.SequenceSchema,
			&i.SequenceName,
			&i.DataType,
			&i.StartValue,
			&i.MinimumValue,
			&i.MaximumValue,
			&i.Increment,
			&i.CycleOption,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTables = `-- name: GetTables :many
SELECT 
    t.table_schema,
    t.table_name,
    t.table_type,
    d.description AS table_comment
FROM information_schema.tables t
LEFT JOIN pg_class c ON c.relname = t.table_name
LEFT JOIN pg_namespace n ON c.relnamespace = n.oid AND n.nspname = t.table_schema
LEFT JOIN pg_description d ON d.objoid = c.oid AND d.classoid = 'pg_class'::regclass AND d.objsubid = 0
WHERE 
    t.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND t.table_schema NOT LIKE 'pg_temp_%'
    AND t.table_schema NOT LIKE 'pg_toast_temp_%'
    AND t.table_type IN ('BASE TABLE', 'VIEW')
ORDER BY t.table_schema, t.table_name
`

type GetTablesRow struct {
	TableSchema  interface{}
	TableName    interface{}
	TableType    interface{}
	TableComment interface{}
}

// GetTables retrieves all tables in the database with metadata
func (q *Queries) GetTables(ctx context.Context) ([]GetTablesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTables)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTablesRow
	for rows.Next() {
		var i GetTablesRow
		if err := rows.Scan(&i.TableSchema, &i.TableName, &i.TableType, &i.TableComment); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTriggers = `-- name: GetTriggers :many
SELECT 
    trigger_schema,
    trigger_name,
    event_object_table,
    action_timing,
    event_manipulation,
    action_statement
FROM information_schema.triggers
WHERE 
    trigger_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND trigger_schema NOT LIKE 'pg_temp_%'
    AND trigger_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY trigger_schema, event_object_table, trigger_name
`

type GetTriggersRow struct {
	TriggerSchema     interface{}
	TriggerName       interface{}
	EventObjectTable  interface{}
	ActionTiming      interface{}
	EventManipulation interface{}
	ActionStatement   interface{}
}

// GetTriggers retrieves all triggers
func (q *Queries) GetTriggers(ctx context.Context) ([]GetTriggersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTriggers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTriggersRow
	for rows.Next() {
		var i GetTriggersRow
		if err := rows.Scan(
			&i.TriggerSchema,
			&i.TriggerName,
			&i.EventObjectTable,
			&i.ActionTiming,
			&i.EventManipulation,
			&i.ActionStatement,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getViewDependencies = `-- name: GetViewDependencies :many
SELECT DISTINCT
    vtu.view_schema AS dependent_schema,
    vtu.view_name AS dependent_name,
    vtu.table_schema AS source_schema,
    vtu.table_name AS source_name
FROM information_schema.view_table_usage vtu
WHERE 
    vtu.view_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND vtu.view_schema NOT LIKE 'pg_temp_%'
    AND vtu.view_schema NOT LIKE 'pg_toast_temp_%'
    AND vtu.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND vtu.table_schema NOT LIKE 'pg_temp_%'
    AND vtu.table_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY vtu.view_schema, vtu.view_name, vtu.table_schema, vtu.table_name
`

type GetViewDependenciesRow struct {
	DependentSchema interface{}
	DependentName   interface{}
	SourceSchema    interface{}
	SourceName      interface{}
}

// GetViewDependencies retrieves view dependencies on tables and other views
func (q *Queries) GetViewDependencies(ctx context.Context) ([]GetViewDependenciesRow, error) {
	rows, err := q.db.QueryContext(ctx, getViewDependencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetViewDependenciesRow
	for rows.Next() {
		var i GetViewDependenciesRow
		if err := rows.Scan(
			&i.DependentSchema,
			&i.DependentName,
			&i.SourceSchema,
			&i.SourceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getViews = `-- name: GetViews :many
SELECT 
    v.table_schema,
    v.table_name,
    v.view_definition,
    d.description AS view_comment
FROM information_schema.views v
LEFT JOIN pg_class c ON c.relname = v.table_name
LEFT JOIN pg_namespace n ON c.relnamespace = n.oid AND n.nspname = v.table_schema
LEFT JOIN pg_description d ON d.objoid = c.oid AND d.classoid = 'pg_class'::regclass AND d.objsubid = 0
WHERE 
    v.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND v.table_schema NOT LIKE 'pg_temp_%'
    AND v.table_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY v.table_schema, v.table_name
`

type GetViewsRow struct {
	TableSchema    interface{}
	TableName      interface{}
	ViewDefinition interface{}
	ViewComment    interface{}
}

// GetViews retrieves all views
func (q *Queries) GetViews(ctx context.Context) ([]GetViewsRow, error) {
	rows, err := q.db.QueryContext(ctx, getViews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetViewsRow
	for rows.Next() {
		var i GetViewsRow
		if err := rows.Scan(&i.TableSchema, &i.TableName, &i.ViewDefinition, &i.ViewComment); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypes = `-- name: GetTypes :many
SELECT 
    n.nspname AS type_schema,
    t.typname AS type_name,
    CASE t.typtype
        WHEN 'e' THEN 'ENUM'
        WHEN 'c' THEN 'COMPOSITE'
        ELSE 'OTHER'
    END AS type_kind,
    d.description AS type_comment
FROM pg_type t
JOIN pg_namespace n ON t.typnamespace = n.oid
LEFT JOIN pg_description d ON d.objoid = t.oid AND d.classoid = 'pg_type'::regclass
LEFT JOIN pg_class c ON t.typrelid = c.oid
WHERE t.typtype IN ('e', 'c')  -- ENUM and composite types only
    AND n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
    AND (t.typtype = 'e' OR (t.typtype = 'c' AND c.relkind = 'c'))  -- For composite types, only include true composite types (not table types)
ORDER BY n.nspname, t.typname
`

type GetTypesRow struct {
	TypeSchema  string
	TypeName    string
	TypeKind    string
	TypeComment interface{}
}

// GetTypes retrieves all user-defined types (ENUM and composite types)
func (q *Queries) GetTypes(ctx context.Context) ([]GetTypesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTypesRow
	for rows.Next() {
		var i GetTypesRow
		if err := rows.Scan(&i.TypeSchema, &i.TypeName, &i.TypeKind, &i.TypeComment); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnumValues = `-- name: GetEnumValues :many
SELECT 
    n.nspname AS type_schema,
    t.typname AS type_name,
    e.enumlabel AS enum_value,
    e.enumsortorder AS enum_order
FROM pg_enum e
JOIN pg_type t ON e.enumtypid = t.oid
JOIN pg_namespace n ON t.typnamespace = n.oid
WHERE n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
ORDER BY n.nspname, t.typname, e.enumsortorder
`

type GetEnumValuesRow struct {
	TypeSchema string
	TypeName   string
	EnumValue  string
	EnumOrder  interface{}
}

// GetEnumValues retrieves enum values for ENUM types
func (q *Queries) GetEnumValues(ctx context.Context) ([]GetEnumValuesRow, error) {
	rows, err := q.db.QueryContext(ctx, getEnumValues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEnumValuesRow
	for rows.Next() {
		var i GetEnumValuesRow
		if err := rows.Scan(&i.TypeSchema, &i.TypeName, &i.EnumValue, &i.EnumOrder); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompositeTypeColumns = `-- name: GetCompositeTypeColumns :many
SELECT 
    n.nspname AS type_schema,
    t.typname AS type_name,
    a.attname AS column_name,
    a.attnum AS column_position,
    format_type(a.atttypid, a.atttypmod) AS column_type
FROM pg_type t
JOIN pg_namespace n ON t.typnamespace = n.oid
JOIN pg_class c ON t.typrelid = c.oid
JOIN pg_attribute a ON c.oid = a.attrelid
WHERE t.typtype = 'c'  -- composite types only
    AND c.relkind = 'c'  -- only true composite types, not table types
    AND a.attnum > 0  -- exclude system columns
    AND NOT a.attisdropped  -- exclude dropped columns
    AND n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
ORDER BY n.nspname, t.typname, a.attnum
`

type GetCompositeTypeColumnsRow struct {
	TypeSchema     string
	TypeName       string
	ColumnName     string
	ColumnPosition interface{}
	ColumnType     string
}

// GetCompositeTypeColumns retrieves columns for composite types
func (q *Queries) GetCompositeTypeColumns(ctx context.Context) ([]GetCompositeTypeColumnsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompositeTypeColumns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompositeTypeColumnsRow
	for rows.Next() {
		var i GetCompositeTypeColumnsRow
		if err := rows.Scan(&i.TypeSchema, &i.TypeName, &i.ColumnName, &i.ColumnPosition, &i.ColumnType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

