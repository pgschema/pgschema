// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package queries

import (
	"context"
)

const getColumns = `-- name: GetColumns :many
SELECT 
    c.table_schema,
    c.table_name,
    c.column_name,
    c.ordinal_position,
    c.column_default,
    c.is_nullable,
    c.data_type,
    c.character_maximum_length,
    c.numeric_precision,
    c.numeric_scale,
    c.udt_name
FROM information_schema.columns c
WHERE 
    c.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND c.table_schema NOT LIKE 'pg_temp_%'
    AND c.table_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY c.table_schema, c.table_name, c.ordinal_position
`

type GetColumnsRow struct {
	TableSchema            interface{}
	TableName              interface{}
	ColumnName             interface{}
	OrdinalPosition        interface{}
	ColumnDefault          interface{}
	IsNullable             interface{}
	DataType               interface{}
	CharacterMaximumLength interface{}
	NumericPrecision       interface{}
	NumericScale           interface{}
	UdtName                interface{}
}

// GetColumns retrieves all columns for all tables
func (q *Queries) GetColumns(ctx context.Context) ([]GetColumnsRow, error) {
	rows, err := q.db.QueryContext(ctx, getColumns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetColumnsRow
	for rows.Next() {
		var i GetColumnsRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.ColumnName,
			&i.OrdinalPosition,
			&i.ColumnDefault,
			&i.IsNullable,
			&i.DataType,
			&i.CharacterMaximumLength,
			&i.NumericPrecision,
			&i.NumericScale,
			&i.UdtName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConstraints = `-- name: GetConstraints :many
SELECT 
    tc.table_schema,
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    kcu.column_name,
    ccu.table_schema AS foreign_table_schema,
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name,
    cc.check_clause
FROM information_schema.table_constraints tc
LEFT JOIN information_schema.key_column_usage kcu 
    ON tc.constraint_name = kcu.constraint_name 
    AND tc.table_schema = kcu.table_schema
LEFT JOIN information_schema.constraint_column_usage ccu 
    ON tc.constraint_name = ccu.constraint_name 
    AND tc.table_schema = ccu.table_schema
LEFT JOIN information_schema.check_constraints cc 
    ON tc.constraint_name = cc.constraint_name 
    AND tc.table_schema = cc.constraint_schema
WHERE 
    tc.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND tc.table_schema NOT LIKE 'pg_temp_%'
    AND tc.table_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY tc.table_schema, tc.table_name, tc.constraint_type, tc.constraint_name
`

type GetConstraintsRow struct {
	TableSchema        interface{}
	TableName          interface{}
	ConstraintName     interface{}
	ConstraintType     interface{}
	ColumnName         interface{}
	ForeignTableSchema interface{}
	ForeignTableName   interface{}
	ForeignColumnName  interface{}
	CheckClause        interface{}
}

// GetConstraints retrieves all table constraints
func (q *Queries) GetConstraints(ctx context.Context) ([]GetConstraintsRow, error) {
	rows, err := q.db.QueryContext(ctx, getConstraints)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConstraintsRow
	for rows.Next() {
		var i GetConstraintsRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.ConstraintName,
			&i.ConstraintType,
			&i.ColumnName,
			&i.ForeignTableSchema,
			&i.ForeignTableName,
			&i.ForeignColumnName,
			&i.CheckClause,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExtensions = `-- name: GetExtensions :many
SELECT 
    'public' AS schema_name,
    'placeholder' AS extension_name,
    'placeholder' AS extension_version
WHERE false
`

type GetExtensionsRow struct {
	SchemaName       string
	ExtensionName    string
	ExtensionVersion string
}

// GetExtensions retrieves all extensions (placeholder for now)
func (q *Queries) GetExtensions(ctx context.Context) ([]GetExtensionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getExtensions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExtensionsRow
	for rows.Next() {
		var i GetExtensionsRow
		if err := rows.Scan(&i.SchemaName, &i.ExtensionName, &i.ExtensionVersion); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFunctions = `-- name: GetFunctions :many
SELECT 
    routine_schema,
    routine_name,
    routine_definition,
    routine_type,
    data_type,
    external_language
FROM information_schema.routines
WHERE 
    routine_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND routine_schema NOT LIKE 'pg_temp_%'
    AND routine_schema NOT LIKE 'pg_toast_temp_%'
    AND routine_type = 'FUNCTION'
ORDER BY routine_schema, routine_name
`

type GetFunctionsRow struct {
	RoutineSchema     interface{}
	RoutineName       interface{}
	RoutineDefinition interface{}
	RoutineType       interface{}
	DataType          interface{}
	ExternalLanguage  interface{}
}

// GetFunctions retrieves all user-defined functions
func (q *Queries) GetFunctions(ctx context.Context) ([]GetFunctionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFunctions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFunctionsRow
	for rows.Next() {
		var i GetFunctionsRow
		if err := rows.Scan(
			&i.RoutineSchema,
			&i.RoutineName,
			&i.RoutineDefinition,
			&i.RoutineType,
			&i.DataType,
			&i.ExternalLanguage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndexes = `-- name: GetIndexes :many
SELECT 
    tc.table_schema as schemaname,
    tc.table_name as tablename,
    tc.constraint_name as indexname,
    'INDEX' as indextype
FROM information_schema.table_constraints tc
WHERE 
    tc.constraint_type IN ('PRIMARY KEY', 'UNIQUE')
    AND tc.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND tc.table_schema NOT LIKE 'pg_temp_%'
    AND tc.table_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY tc.table_schema, tc.table_name, tc.constraint_name
`

type GetIndexesRow struct {
	Schemaname interface{}
	Tablename  interface{}
	Indexname  interface{}
	Indextype  string
}

// GetIndexes retrieves all indexes (simplified for sqlc compatibility)
func (q *Queries) GetIndexes(ctx context.Context) ([]GetIndexesRow, error) {
	rows, err := q.db.QueryContext(ctx, getIndexes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIndexesRow
	for rows.Next() {
		var i GetIndexesRow
		if err := rows.Scan(
			&i.Schemaname,
			&i.Tablename,
			&i.Indexname,
			&i.Indextype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchemas = `-- name: GetSchemas :many
SELECT 
    schema_name
FROM information_schema.schemata
WHERE 
    schema_name NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND schema_name NOT LIKE 'pg_temp_%'
    AND schema_name NOT LIKE 'pg_toast_temp_%'
ORDER BY schema_name
`

// GetSchemas retrieves all user-defined schemas
func (q *Queries) GetSchemas(ctx context.Context) ([]interface{}, error) {
	rows, err := q.db.QueryContext(ctx, getSchemas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var schema_name interface{}
		if err := rows.Scan(&schema_name); err != nil {
			return nil, err
		}
		items = append(items, schema_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSequences = `-- name: GetSequences :many
SELECT 
    sequence_schema,
    sequence_name,
    data_type,
    start_value,
    minimum_value,
    maximum_value,
    increment,
    cycle_option
FROM information_schema.sequences
WHERE 
    sequence_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND sequence_schema NOT LIKE 'pg_temp_%'
    AND sequence_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY sequence_schema, sequence_name
`

type GetSequencesRow struct {
	SequenceSchema interface{}
	SequenceName   interface{}
	DataType       interface{}
	StartValue     interface{}
	MinimumValue   interface{}
	MaximumValue   interface{}
	Increment      interface{}
	CycleOption    interface{}
}

// GetSequences retrieves all sequences
func (q *Queries) GetSequences(ctx context.Context) ([]GetSequencesRow, error) {
	rows, err := q.db.QueryContext(ctx, getSequences)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSequencesRow
	for rows.Next() {
		var i GetSequencesRow
		if err := rows.Scan(
			&i.SequenceSchema,
			&i.SequenceName,
			&i.DataType,
			&i.StartValue,
			&i.MinimumValue,
			&i.MaximumValue,
			&i.Increment,
			&i.CycleOption,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTables = `-- name: GetTables :many
SELECT 
    t.table_schema,
    t.table_name,
    t.table_type
FROM information_schema.tables t
WHERE 
    t.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND t.table_schema NOT LIKE 'pg_temp_%'
    AND t.table_schema NOT LIKE 'pg_toast_temp_%'
    AND t.table_type IN ('BASE TABLE', 'VIEW')
ORDER BY t.table_schema, t.table_name
`

type GetTablesRow struct {
	TableSchema interface{}
	TableName   interface{}
	TableType   interface{}
}

// GetTables retrieves all tables in the database with metadata
func (q *Queries) GetTables(ctx context.Context) ([]GetTablesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTables)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTablesRow
	for rows.Next() {
		var i GetTablesRow
		if err := rows.Scan(&i.TableSchema, &i.TableName, &i.TableType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTriggers = `-- name: GetTriggers :many
SELECT 
    trigger_schema,
    trigger_name,
    event_object_table,
    action_timing,
    event_manipulation,
    action_statement
FROM information_schema.triggers
WHERE 
    trigger_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND trigger_schema NOT LIKE 'pg_temp_%'
    AND trigger_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY trigger_schema, event_object_table, trigger_name
`

type GetTriggersRow struct {
	TriggerSchema     interface{}
	TriggerName       interface{}
	EventObjectTable  interface{}
	ActionTiming      interface{}
	EventManipulation interface{}
	ActionStatement   interface{}
}

// GetTriggers retrieves all triggers
func (q *Queries) GetTriggers(ctx context.Context) ([]GetTriggersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTriggers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTriggersRow
	for rows.Next() {
		var i GetTriggersRow
		if err := rows.Scan(
			&i.TriggerSchema,
			&i.TriggerName,
			&i.EventObjectTable,
			&i.ActionTiming,
			&i.EventManipulation,
			&i.ActionStatement,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getViewDependencies = `-- name: GetViewDependencies :many
SELECT DISTINCT
    vtu.view_schema AS dependent_schema,
    vtu.view_name AS dependent_name,
    vtu.table_schema AS source_schema,
    vtu.table_name AS source_name
FROM information_schema.view_table_usage vtu
WHERE 
    vtu.view_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND vtu.view_schema NOT LIKE 'pg_temp_%'
    AND vtu.view_schema NOT LIKE 'pg_toast_temp_%'
    AND vtu.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND vtu.table_schema NOT LIKE 'pg_temp_%'
    AND vtu.table_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY vtu.view_schema, vtu.view_name, vtu.table_schema, vtu.table_name
`

type GetViewDependenciesRow struct {
	DependentSchema interface{}
	DependentName   interface{}
	SourceSchema    interface{}
	SourceName      interface{}
}

// GetViewDependencies retrieves view dependencies on tables and other views
func (q *Queries) GetViewDependencies(ctx context.Context) ([]GetViewDependenciesRow, error) {
	rows, err := q.db.QueryContext(ctx, getViewDependencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetViewDependenciesRow
	for rows.Next() {
		var i GetViewDependenciesRow
		if err := rows.Scan(
			&i.DependentSchema,
			&i.DependentName,
			&i.SourceSchema,
			&i.SourceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getViews = `-- name: GetViews :many
SELECT 
    table_schema,
    table_name,
    view_definition
FROM information_schema.views
WHERE 
    table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND table_schema NOT LIKE 'pg_temp_%'
    AND table_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY table_schema, table_name
`

type GetViewsRow struct {
	TableSchema    interface{}
	TableName      interface{}
	ViewDefinition interface{}
}

// GetViews retrieves all views
func (q *Queries) GetViews(ctx context.Context) ([]GetViewsRow, error) {
	rows, err := q.db.QueryContext(ctx, getViews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetViewsRow
	for rows.Next() {
		var i GetViewsRow
		if err := rows.Scan(&i.TableSchema, &i.TableName, &i.ViewDefinition); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
