package diff

import (
	"fmt"
	"strings"

	"github.com/pgschema/pgschema/internal/ir"
)


// writeColumnDefinitionToBuilder builds column definitions with SERIAL detection and proper formatting
// This is moved from ir/table.go to consolidate SQL generation in the diff module
func writeColumnDefinitionToBuilder(builder *strings.Builder, table *ir.Table, column *ir.Column, targetSchema string) {
	builder.WriteString(column.Name)
	builder.WriteString(" ")

	// Data type - handle array types and precision/scale for appropriate types
	dataType := column.DataType

	// Handle USER-DEFINED types and domains: use UDTName instead of base type
	if (dataType == "USER-DEFINED" && column.UDTName != "") || strings.Contains(column.UDTName, ".") {
		dataType = column.UDTName
		// Strip schema prefix if it matches the target schema
		dataType = ir.StripSchemaPrefix(dataType, targetSchema)
		// Normalize PostgreSQL internal type names
		dataType = ir.NormalizePostgreSQLType(dataType)
	} else {
		// Strip schema prefix if it matches the target schema
		dataType = ir.StripSchemaPrefix(dataType, targetSchema)
		// Normalize PostgreSQL internal type names
		dataType = ir.NormalizePostgreSQLType(dataType)
	}

	// Check if this is a SERIAL column (integer with nextval default)
	isSerial := isSerialColumn(column)
	if isSerial {
		// Use SERIAL, SMALLSERIAL, or BIGSERIAL based on the data type
		switch dataType {
		case "smallint":
			dataType = "SMALLSERIAL"
		case "bigint":
			dataType = "BIGSERIAL"
		default: // integer
			dataType = "SERIAL"
		}
	} else {
		// Handle array types: if data_type is "ARRAY", use udt_name with [] suffix
		if column.DataType == "ARRAY" && column.UDTName != "" {
			// Remove the underscore prefix from udt_name for array types
			// PostgreSQL stores array element types with a leading underscore
			elementType := column.UDTName
			if strings.HasPrefix(elementType, "_") {
				elementType = elementType[1:]
			}
			// Handle schema qualifiers based on target schema
			if strings.Contains(elementType, ".") {
				parts := strings.Split(elementType, ".")
				schemaName := parts[0]
				typeName := parts[1]
				// Only remove schema qualifier if it matches the target schema
				if schemaName == targetSchema {
					elementType = typeName
				}
				// Otherwise keep the full qualified name (e.g., public.mpaa_rating)
			}
			// Canonicalize internal type names for array elements (e.g., int4 -> integer, int8 -> bigint)
			elementType = ir.NormalizePostgreSQLType(elementType)
			dataType = elementType + "[]"
		} else if column.MaxLength != nil && (dataType == "character varying" || dataType == "varchar") {
			dataType = fmt.Sprintf("character varying(%d)", *column.MaxLength)
		} else if column.MaxLength != nil && dataType == "character" {
			dataType = fmt.Sprintf("character(%d)", *column.MaxLength)
		} else if column.Precision != nil && column.Scale != nil && (dataType == "numeric" || dataType == "decimal") {
			dataType = fmt.Sprintf("%s(%d,%d)", dataType, *column.Precision, *column.Scale)
		} else if column.Precision != nil && (dataType == "numeric" || dataType == "decimal") {
			dataType = fmt.Sprintf("%s(%d)", dataType, *column.Precision)
		}
		// For integer types like "integer", "bigint", "smallint", do not add precision/scale
	}

	builder.WriteString(dataType)

	// Identity columns
	if column.IsIdentity {
		if column.IdentityGeneration == "ALWAYS" {
			builder.WriteString(" GENERATED ALWAYS AS IDENTITY")
		} else if column.IdentityGeneration == "BY DEFAULT" {
			builder.WriteString(" GENERATED BY DEFAULT AS IDENTITY")
		}
	}

	// Default (include all defaults inline, but skip for SERIAL columns)
	if column.DefaultValue != nil && !column.IsIdentity && !isSerial {
		defaultValue := *column.DefaultValue
		// Handle schema-agnostic sequence references in defaults
		if strings.Contains(defaultValue, "nextval") {
			// Remove schema qualifiers from sequence references in the target schema
			// Use targetSchema if provided, otherwise fall back to the table's schema
			schemaToRemove := targetSchema
			if schemaToRemove == "" {
				schemaToRemove = table.Schema
			}
			schemaPrefix := schemaToRemove + "."
			defaultValue = strings.ReplaceAll(defaultValue, schemaPrefix, "")
		}
		
		// Strip type qualifiers from default values
		defaultValue = stripTypeQualifiers(defaultValue)
		
		builder.WriteString(fmt.Sprintf(" DEFAULT %s", defaultValue))
	}

	// Nullability
	if !column.IsNullable {
		builder.WriteString(" NOT NULL")
	}

	// Add inline CHECK constraints for this column
	for _, constraint := range table.Constraints {
		if constraint.Type == ir.ConstraintTypeCheck && 
		   len(constraint.Columns) == 1 && 
		   constraint.Columns[0].Name == column.Name {
			// Use simpler format for inline CHECK constraints
			checkClause := constraint.CheckClause
			// Remove the "CHECK " prefix if present to get just the condition
			if strings.HasPrefix(checkClause, "CHECK ") {
				checkClause = strings.TrimPrefix(checkClause, "CHECK ")
			}
			// Simplify verbose PostgreSQL CHECK expressions to developer-friendly format
			checkClause = simplifyCheckClause(checkClause)
			builder.WriteString(fmt.Sprintf(" CHECK (%s)", checkClause))
		}
	}
}

// isSerialColumn checks if a column is a SERIAL column (integer type with nextval default)
func isSerialColumn(column *ir.Column) bool {
	// Check if column has nextval default
	if column.DefaultValue == nil || !strings.Contains(*column.DefaultValue, "nextval") {
		return false
	}

	// Check if column is an integer type
	switch column.DataType {
	case "integer", "int4", "smallint", "int2", "bigint", "int8":
		return true
	default:
		return false
	}
}


// stripTypeQualifiers removes PostgreSQL type qualifiers from default values
func stripTypeQualifiers(defaultValue string) string {
	// Common PostgreSQL type qualifiers that should be stripped from default values
	typeQualifiers := []string{
		"::text",
		"::jsonb", 
		"::json",
		"::numeric",
		"::decimal",
		"::integer",
		"::int",
		"::bigint",
		"::smallint",
		"::boolean",
		"::bool",
		"::character varying",
		"::varchar",
		"::character",
		"::bpchar",
		"::timestamp",
		"::timestamptz",
		"::time",
		"::timetz",
		"::date",
		"::real",
		"::double precision",
		"::bytea",
		"::uuid",
		"::inet",
		"::cidr",
		"::macaddr",
		"::xml",
	}

	for _, qualifier := range typeQualifiers {
		if strings.HasSuffix(defaultValue, qualifier) {
			return strings.TrimSuffix(defaultValue, qualifier)
		}
	}
	return defaultValue
}

// simplifyCheckClause converts verbose PostgreSQL CHECK expressions to developer-friendly format
func simplifyCheckClause(checkClause string) string {
	// Remove outer parentheses if present (may be multiple layers)
	checkClause = strings.TrimSpace(checkClause)
	for strings.HasPrefix(checkClause, "(") && strings.HasSuffix(checkClause, ")") {
		checkClause = strings.TrimSpace(checkClause[1 : len(checkClause)-1])
	}
	
	// Convert "column = ANY (ARRAY['val1'::text, 'val2'::text])" to "column IN('val1', 'val2')"
	if strings.Contains(checkClause, "= ANY (ARRAY[") {
		// Extract the column name and values
		parts := strings.Split(checkClause, " = ANY (ARRAY[")
		if len(parts) == 2 {
			columnName := strings.TrimSpace(parts[0])
			
			// Remove the closing ])))
			valuesPart := parts[1]
			if strings.HasSuffix(valuesPart, "])") {
				valuesPart = valuesPart[:len(valuesPart)-2]
			}
			if strings.HasSuffix(valuesPart, "])) ") {
				valuesPart = valuesPart[:len(valuesPart)-4]
			}
			if strings.HasSuffix(valuesPart, "]))") {
				valuesPart = valuesPart[:len(valuesPart)-3]
			}
			if strings.HasSuffix(valuesPart, "])") {
				valuesPart = valuesPart[:len(valuesPart)-2]
			}
			
			// Split the values and clean them up
			values := strings.Split(valuesPart, ", ")
			var cleanValues []string
			for _, val := range values {
				val = strings.TrimSpace(val)
				// Remove type casts like ::text
				if idx := strings.Index(val, "::"); idx != -1 {
					val = val[:idx]
				}
				cleanValues = append(cleanValues, val)
			}
			
			return fmt.Sprintf("%s IN(%s)", columnName, strings.Join(cleanValues, ", "))
		}
	}
	
	// Convert "column ~~ 'pattern'::text" to "column LIKE 'pattern'"
	if strings.Contains(checkClause, " ~~ ") {
		parts := strings.Split(checkClause, " ~~ ")
		if len(parts) == 2 {
			columnName := strings.TrimSpace(parts[0])
			pattern := strings.TrimSpace(parts[1])
			// Remove type cast
			if idx := strings.Index(pattern, "::"); idx != -1 {
				pattern = pattern[:idx]
			}
			return fmt.Sprintf("%s LIKE %s", columnName, pattern)
		}
	}
	
	// If no simplification matched, return the clause as-is
	return checkClause
}

