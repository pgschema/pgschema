// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const getAggregates = `-- name: GetAggregates :many
SELECT 
    n.nspname AS aggregate_schema,
    p.proname AS aggregate_name,
    pg_get_function_arguments(p.oid) AS aggregate_signature,
    oidvectortypes(p.proargtypes) AS aggregate_arguments,
    format_type(p.prorettype, NULL) AS aggregate_return_type,
    -- Get transition function
    COALESCE(tf.proname, '') AS transition_function,
    COALESCE(tfn.nspname, '') AS transition_function_schema,
    -- Get state type
    format_type(a.aggtranstype, NULL) AS state_type,
    -- Get initial condition
    a.agginitval AS initial_condition,
    -- Get final function if exists
    COALESCE(ff.proname, '') AS final_function,
    COALESCE(ffn.nspname, '') AS final_function_schema,
    -- Comment
    COALESCE(d.description, '') AS aggregate_comment
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
JOIN pg_aggregate a ON a.aggfnoid = p.oid
LEFT JOIN pg_proc tf ON a.aggtransfn = tf.oid
LEFT JOIN pg_namespace tfn ON tf.pronamespace = tfn.oid
LEFT JOIN pg_proc ff ON a.aggfinalfn = ff.oid
LEFT JOIN pg_namespace ffn ON ff.pronamespace = ffn.oid
LEFT JOIN pg_description d ON d.objoid = p.oid AND d.classoid = 'pg_proc'::regclass
WHERE p.prokind = 'a'  -- Only aggregates
    AND n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
    AND NOT EXISTS (
        SELECT 1 FROM pg_depend dep 
        WHERE dep.objid = p.oid AND dep.deptype = 'e'
    )  -- Exclude extension members
ORDER BY n.nspname, p.proname
`

type GetAggregatesRow struct {
	AggregateSchema          string         `db:"aggregate_schema" json:"aggregate_schema"`
	AggregateName            string         `db:"aggregate_name" json:"aggregate_name"`
	AggregateSignature       sql.NullString `db:"aggregate_signature" json:"aggregate_signature"`
	AggregateArguments       sql.NullString `db:"aggregate_arguments" json:"aggregate_arguments"`
	AggregateReturnType      sql.NullString `db:"aggregate_return_type" json:"aggregate_return_type"`
	TransitionFunction       sql.NullString `db:"transition_function" json:"transition_function"`
	TransitionFunctionSchema sql.NullString `db:"transition_function_schema" json:"transition_function_schema"`
	StateType                sql.NullString `db:"state_type" json:"state_type"`
	InitialCondition         sql.NullString `db:"initial_condition" json:"initial_condition"`
	FinalFunction            sql.NullString `db:"final_function" json:"final_function"`
	FinalFunctionSchema      sql.NullString `db:"final_function_schema" json:"final_function_schema"`
	AggregateComment         sql.NullString `db:"aggregate_comment" json:"aggregate_comment"`
}

// GetAggregates retrieves all user-defined aggregates
func (q *Queries) GetAggregates(ctx context.Context) ([]GetAggregatesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAggregates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAggregatesRow
	for rows.Next() {
		var i GetAggregatesRow
		if err := rows.Scan(
			&i.AggregateSchema,
			&i.AggregateName,
			&i.AggregateSignature,
			&i.AggregateArguments,
			&i.AggregateReturnType,
			&i.TransitionFunction,
			&i.TransitionFunctionSchema,
			&i.StateType,
			&i.InitialCondition,
			&i.FinalFunction,
			&i.FinalFunctionSchema,
			&i.AggregateComment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAggregatesForSchema = `-- name: GetAggregatesForSchema :many
SELECT 
    n.nspname AS aggregate_schema,
    p.proname AS aggregate_name,
    pg_get_function_arguments(p.oid) AS aggregate_signature,
    oidvectortypes(p.proargtypes) AS aggregate_arguments,
    format_type(p.prorettype, NULL) AS aggregate_return_type,
    -- Get transition function
    COALESCE(tf.proname, '') AS transition_function,
    COALESCE(tfn.nspname, '') AS transition_function_schema,
    -- Get state type
    format_type(a.aggtranstype, NULL) AS state_type,
    -- Get initial condition
    a.agginitval AS initial_condition,
    -- Get final function if exists
    COALESCE(ff.proname, '') AS final_function,
    COALESCE(ffn.nspname, '') AS final_function_schema,
    -- Comment
    COALESCE(d.description, '') AS aggregate_comment
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
JOIN pg_aggregate a ON a.aggfnoid = p.oid
LEFT JOIN pg_proc tf ON a.aggtransfn = tf.oid
LEFT JOIN pg_namespace tfn ON tf.pronamespace = tfn.oid
LEFT JOIN pg_proc ff ON a.aggfinalfn = ff.oid
LEFT JOIN pg_namespace ffn ON ff.pronamespace = ffn.oid
LEFT JOIN pg_description d ON d.objoid = p.oid AND d.classoid = 'pg_proc'::regclass
WHERE p.prokind = 'a'  -- Only aggregates
    AND n.nspname = $1
    AND NOT EXISTS (
        SELECT 1 FROM pg_depend dep 
        WHERE dep.objid = p.oid AND dep.deptype = 'e'
    )  -- Exclude extension members
ORDER BY n.nspname, p.proname
`

type GetAggregatesForSchemaRow struct {
	AggregateSchema          string         `db:"aggregate_schema" json:"aggregate_schema"`
	AggregateName            string         `db:"aggregate_name" json:"aggregate_name"`
	AggregateSignature       sql.NullString `db:"aggregate_signature" json:"aggregate_signature"`
	AggregateArguments       sql.NullString `db:"aggregate_arguments" json:"aggregate_arguments"`
	AggregateReturnType      sql.NullString `db:"aggregate_return_type" json:"aggregate_return_type"`
	TransitionFunction       sql.NullString `db:"transition_function" json:"transition_function"`
	TransitionFunctionSchema sql.NullString `db:"transition_function_schema" json:"transition_function_schema"`
	StateType                sql.NullString `db:"state_type" json:"state_type"`
	InitialCondition         sql.NullString `db:"initial_condition" json:"initial_condition"`
	FinalFunction            sql.NullString `db:"final_function" json:"final_function"`
	FinalFunctionSchema      sql.NullString `db:"final_function_schema" json:"final_function_schema"`
	AggregateComment         sql.NullString `db:"aggregate_comment" json:"aggregate_comment"`
}

// GetAggregatesForSchema retrieves all user-defined aggregates for a specific schema
func (q *Queries) GetAggregatesForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetAggregatesForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getAggregatesForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAggregatesForSchemaRow
	for rows.Next() {
		var i GetAggregatesForSchemaRow
		if err := rows.Scan(
			&i.AggregateSchema,
			&i.AggregateName,
			&i.AggregateSignature,
			&i.AggregateArguments,
			&i.AggregateReturnType,
			&i.TransitionFunction,
			&i.TransitionFunctionSchema,
			&i.StateType,
			&i.InitialCondition,
			&i.FinalFunction,
			&i.FinalFunctionSchema,
			&i.AggregateComment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnPrivilegesForSchema = `-- name: GetColumnPrivilegesForSchema :many
WITH column_acls AS (
    SELECT
        c.relname AS table_name,
        a.attname AS column_name,
        a.attacl AS acl
    FROM pg_attribute a
    JOIN pg_class c ON a.attrelid = c.oid
    JOIN pg_namespace n ON c.relnamespace = n.oid
    WHERE n.nspname = $1
        AND c.relkind IN ('r', 'v', 'm')  -- tables, views, materialized views
        AND a.attnum > 0                   -- skip system columns
        AND NOT a.attisdropped
        AND a.attacl IS NOT NULL           -- only columns with explicit ACL
)
SELECT
    table_name,
    column_name,
    (aclexplode(acl)).grantee AS grantee_oid,
    (aclexplode(acl)).privilege_type AS privilege_type,
    (aclexplode(acl)).is_grantable AS is_grantable
FROM column_acls
ORDER BY table_name, column_name, grantee_oid, privilege_type
`

type GetColumnPrivilegesForSchemaRow struct {
	TableName     string         `db:"table_name" json:"table_name"`
	ColumnName    string         `db:"column_name" json:"column_name"`
	GranteeOid    interface{}    `db:"grantee_oid" json:"grantee_oid"`
	PrivilegeType sql.NullString `db:"privilege_type" json:"privilege_type"`
	IsGrantable   sql.NullBool   `db:"is_grantable" json:"is_grantable"`
}

// GetColumnPrivilegesForSchema retrieves column-level privilege grants
// Column privileges are stored in pg_attribute.attacl and allow fine-grained access
func (q *Queries) GetColumnPrivilegesForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetColumnPrivilegesForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getColumnPrivilegesForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetColumnPrivilegesForSchemaRow
	for rows.Next() {
		var i GetColumnPrivilegesForSchemaRow
		if err := rows.Scan(
			&i.TableName,
			&i.ColumnName,
			&i.GranteeOid,
			&i.PrivilegeType,
			&i.IsGrantable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumns = `-- name: GetColumns :many
WITH column_base AS (
    SELECT
        c.table_schema,
        c.table_name,
        c.column_name,
        c.ordinal_position,
        c.column_default,
        c.is_nullable,
        c.data_type,
        c.character_maximum_length,
        c.numeric_precision,
        c.numeric_scale,
        c.udt_name,
        COALESCE(d.description, '') AS column_comment,
        CASE
            WHEN dt.typtype = 'd' THEN
                CASE WHEN dn.nspname = c.table_schema THEN dt.typname
                     ELSE dn.nspname || '.' || dt.typname
                END
            WHEN dt.typtype = 'e' OR dt.typtype = 'c' THEN
                CASE WHEN dn.nspname = c.table_schema THEN dt.typname
                     ELSE dn.nspname || '.' || dt.typname
                END
            WHEN dt.typtype = 'b' AND dt.typelem <> 0 THEN
                -- Array types: apply same schema qualification logic to element type
                CASE
                    WHEN en.nspname = 'pg_catalog' THEN et.typname || '[]'
                    WHEN en.nspname = c.table_schema THEN et.typname || '[]'
                    ELSE en.nspname || '.' || et.typname || '[]'
                END
            WHEN dt.typtype = 'b' THEN
                -- Non-array base types: qualify if not in pg_catalog or table's schema
                -- Use format_type to preserve typmod for extension types (e.g., vector(384) for pgvector)
                CASE
                    WHEN dn.nspname = 'pg_catalog' THEN c.udt_name
                    WHEN dn.nspname = c.table_schema THEN
                        dt.typname || COALESCE(substring(format_type(a.atttypid, a.atttypmod) FROM '\([^)]*\)'), '')
                    ELSE
                        dn.nspname || '.' || dt.typname || COALESCE(substring(format_type(a.atttypid, a.atttypmod) FROM '\([^)]*\)'), '')
                END
            ELSE c.udt_name
        END AS resolved_type,
        c.is_identity,
        c.identity_generation,
        c.identity_start,
        c.identity_increment,
        c.identity_maximum,
        c.identity_minimum,
        c.identity_cycle,
        a.attgenerated,
        ad.adbin,
        ad.adrelid
    FROM information_schema.columns c
    LEFT JOIN pg_namespace n ON n.nspname = c.table_schema
    LEFT JOIN pg_class cl ON cl.relname = c.table_name AND cl.relnamespace = n.oid
    LEFT JOIN pg_description d ON d.objoid = cl.oid AND d.classoid = 'pg_class'::regclass AND d.objsubid = c.ordinal_position
    LEFT JOIN pg_attribute a ON a.attrelid = cl.oid AND a.attname = c.column_name
    LEFT JOIN pg_attrdef ad ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum
    LEFT JOIN pg_type dt ON dt.oid = a.atttypid
    LEFT JOIN pg_namespace dn ON dt.typnamespace = dn.oid
    LEFT JOIN pg_type et ON dt.typelem = et.oid
    LEFT JOIN pg_namespace en ON et.typnamespace = en.oid
    WHERE
        c.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
        AND c.table_schema NOT LIKE 'pg_temp_%'
        AND c.table_schema NOT LIKE 'pg_toast_temp_%'
)
SELECT
    cb.table_schema,
    cb.table_name,
    cb.column_name,
    cb.ordinal_position,
    -- Use the column_default from LATERAL join which has proper search_path set
    ge.column_default,
    cb.is_nullable,
    cb.data_type,
    cb.character_maximum_length,
    cb.numeric_precision,
    cb.numeric_scale,
    cb.udt_name,
    cb.column_comment,
    cb.resolved_type,
    cb.is_identity,
    cb.identity_generation,
    cb.identity_start,
    cb.identity_increment,
    cb.identity_maximum,
    cb.identity_minimum,
    cb.identity_cycle,
    cb.attgenerated,
    -- Use LATERAL join to guarantee execution order:
    -- 1. set_config sets search_path to only the table's schema
    -- 2. pg_get_expr then uses that search_path
    -- This ensures cross-schema type references in column defaults and generated columns
    -- are properly qualified (Issue #218)
    ge.generated_expr
FROM column_base cb
LEFT JOIN LATERAL (
    SELECT
        -- Set search_path to only pg_catalog to force pg_get_expr to include schema qualifiers
        -- for all user-defined types and functions. The normalization code will then strip
        -- same-schema function qualifiers while preserving type qualifiers (Issue #218)
        set_config('search_path', 'pg_catalog', true) as dummy,
        CASE
            WHEN cb.attgenerated = 's' THEN NULL  -- Generated columns don't have defaults
            ELSE COALESCE(pg_get_expr(cb.adbin, cb.adrelid), cb.column_default)
        END as column_default,
        CASE
            WHEN cb.attgenerated = 's' THEN pg_get_expr(cb.adbin, cb.adrelid)
            ELSE NULL
        END as generated_expr
) ge ON true
ORDER BY cb.table_schema, cb.table_name, cb.ordinal_position
`

type GetColumnsRow struct {
	TableSchema            interface{}    `db:"table_schema" json:"table_schema"`
	TableName              interface{}    `db:"table_name" json:"table_name"`
	ColumnName             interface{}    `db:"column_name" json:"column_name"`
	OrdinalPosition        interface{}    `db:"ordinal_position" json:"ordinal_position"`
	ColumnDefault          sql.NullString `db:"column_default" json:"column_default"`
	IsNullable             interface{}    `db:"is_nullable" json:"is_nullable"`
	DataType               interface{}    `db:"data_type" json:"data_type"`
	CharacterMaximumLength interface{}    `db:"character_maximum_length" json:"character_maximum_length"`
	NumericPrecision       interface{}    `db:"numeric_precision" json:"numeric_precision"`
	NumericScale           interface{}    `db:"numeric_scale" json:"numeric_scale"`
	UdtName                interface{}    `db:"udt_name" json:"udt_name"`
	ColumnComment          sql.NullString `db:"column_comment" json:"column_comment"`
	ResolvedType           sql.NullString `db:"resolved_type" json:"resolved_type"`
	IsIdentity             interface{}    `db:"is_identity" json:"is_identity"`
	IdentityGeneration     interface{}    `db:"identity_generation" json:"identity_generation"`
	IdentityStart          interface{}    `db:"identity_start" json:"identity_start"`
	IdentityIncrement      interface{}    `db:"identity_increment" json:"identity_increment"`
	IdentityMaximum        interface{}    `db:"identity_maximum" json:"identity_maximum"`
	IdentityMinimum        interface{}    `db:"identity_minimum" json:"identity_minimum"`
	IdentityCycle          interface{}    `db:"identity_cycle" json:"identity_cycle"`
	Attgenerated           interface{}    `db:"attgenerated" json:"attgenerated"`
	GeneratedExpr          sql.NullString `db:"generated_expr" json:"generated_expr"`
}

// GetColumns retrieves all columns for all tables
func (q *Queries) GetColumns(ctx context.Context) ([]GetColumnsRow, error) {
	rows, err := q.db.QueryContext(ctx, getColumns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetColumnsRow
	for rows.Next() {
		var i GetColumnsRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.ColumnName,
			&i.OrdinalPosition,
			&i.ColumnDefault,
			&i.IsNullable,
			&i.DataType,
			&i.CharacterMaximumLength,
			&i.NumericPrecision,
			&i.NumericScale,
			&i.UdtName,
			&i.ColumnComment,
			&i.ResolvedType,
			&i.IsIdentity,
			&i.IdentityGeneration,
			&i.IdentityStart,
			&i.IdentityIncrement,
			&i.IdentityMaximum,
			&i.IdentityMinimum,
			&i.IdentityCycle,
			&i.Attgenerated,
			&i.GeneratedExpr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnsForSchema = `-- name: GetColumnsForSchema :many
WITH column_base AS (
    SELECT
        c.table_schema,
        c.table_name,
        c.column_name,
        c.ordinal_position,
        c.column_default,
        c.is_nullable,
        c.data_type,
        c.character_maximum_length,
        c.numeric_precision,
        c.numeric_scale,
        c.udt_name,
        COALESCE(d.description, '') AS column_comment,
        CASE
            WHEN dt.typtype = 'd' THEN
                CASE WHEN dn.nspname = c.table_schema THEN dt.typname
                     ELSE dn.nspname || '.' || dt.typname
                END
            WHEN dt.typtype = 'e' OR dt.typtype = 'c' THEN
                CASE WHEN dn.nspname = c.table_schema THEN dt.typname
                     ELSE dn.nspname || '.' || dt.typname
                END
            WHEN dt.typtype = 'b' AND dt.typelem <> 0 THEN
                -- Array types: apply same schema qualification logic to element type
                CASE
                    WHEN en.nspname = 'pg_catalog' THEN et.typname || '[]'
                    WHEN en.nspname = c.table_schema THEN et.typname || '[]'
                    ELSE en.nspname || '.' || et.typname || '[]'
                END
            WHEN dt.typtype = 'b' THEN
                -- Non-array base types: qualify if not in pg_catalog or table's schema
                -- Use format_type to preserve typmod for extension types (e.g., vector(384) for pgvector)
                CASE
                    WHEN dn.nspname = 'pg_catalog' THEN c.udt_name
                    WHEN dn.nspname = c.table_schema THEN
                        dt.typname || COALESCE(substring(format_type(a.atttypid, a.atttypmod) FROM '\([^)]*\)'), '')
                    ELSE
                        dn.nspname || '.' || dt.typname || COALESCE(substring(format_type(a.atttypid, a.atttypmod) FROM '\([^)]*\)'), '')
                END
            ELSE c.udt_name
        END AS resolved_type,
        c.is_identity,
        c.identity_generation,
        c.identity_start,
        c.identity_increment,
        c.identity_maximum,
        c.identity_minimum,
        c.identity_cycle,
        a.attgenerated,
        ad.adbin,
        ad.adrelid,
        cl.oid AS table_oid
    FROM information_schema.columns c
    LEFT JOIN pg_namespace n ON n.nspname = c.table_schema
    LEFT JOIN pg_class cl ON cl.relname = c.table_name AND cl.relnamespace = n.oid
    LEFT JOIN pg_description d ON d.objoid = cl.oid AND d.classoid = 'pg_class'::regclass AND d.objsubid = c.ordinal_position
    LEFT JOIN pg_attribute a ON a.attrelid = cl.oid AND a.attname = c.column_name
    LEFT JOIN pg_attrdef ad ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum
    LEFT JOIN pg_type dt ON dt.oid = a.atttypid
    LEFT JOIN pg_namespace dn ON dt.typnamespace = dn.oid
    LEFT JOIN pg_type et ON dt.typelem = et.oid
    LEFT JOIN pg_namespace en ON et.typnamespace = en.oid
    WHERE
        c.table_schema = $1
)
SELECT
    cb.table_schema,
    cb.table_name,
    cb.column_name,
    cb.ordinal_position,
    -- Use the column_default from LATERAL join which has proper search_path set
    ge.column_default,
    cb.is_nullable,
    cb.data_type,
    cb.character_maximum_length,
    cb.numeric_precision,
    cb.numeric_scale,
    cb.udt_name,
    cb.column_comment,
    cb.resolved_type,
    cb.is_identity,
    cb.identity_generation,
    cb.identity_start,
    cb.identity_increment,
    cb.identity_maximum,
    cb.identity_minimum,
    cb.identity_cycle,
    cb.attgenerated,
    -- Use LATERAL join to guarantee execution order:
    -- 1. set_config sets search_path to only pg_catalog
    -- 2. pg_get_expr then uses that search_path and includes schema qualifiers for user types
    -- This ensures type references in column defaults and generated columns are properly
    -- qualified (Issue #218). The normalization code strips same-schema function qualifiers.
    --
    -- NOTE: The 'dummy' column in the LATERAL subquery forces set_config to execute
    -- before pg_get_expr. PostgreSQL evaluates SELECT columns left-to-right within
    -- a single query level. The LATERAL join guarantees this happens row-by-row,
    -- and 'ON true' in the join condition ensures the LATERAL subquery executes for every row.
    -- This pattern mirrors GetViewsForSchema (line 959-963) for consistency.
    --
    -- Alternative considered: Create a custom PostgreSQL function wrapping pg_get_expr
    -- with search_path control. Rejected because:
    -- 1. Requires creating database objects (function) on target database
    -- 2. pgschema operates in read-only inspection mode
    -- 3. LATERAL join pattern is PostgreSQL-native and well-documented
    ge.generated_expr
FROM column_base cb
LEFT JOIN LATERAL (
    SELECT
        -- Set search_path to only pg_catalog to force pg_get_expr to include schema qualifiers
        -- for all user-defined types and functions. The normalization code will then strip
        -- same-schema function qualifiers while preserving type qualifiers (Issue #218)
        set_config('search_path', 'pg_catalog', true) as dummy,
        CASE
            WHEN cb.attgenerated = 's' THEN NULL  -- Generated columns don't have defaults
            ELSE COALESCE(pg_get_expr(cb.adbin, cb.adrelid), cb.column_default)
        END as column_default,
        CASE
            WHEN cb.attgenerated = 's' THEN pg_get_expr(cb.adbin, cb.adrelid)
            ELSE NULL
        END as generated_expr
) ge ON true
ORDER BY cb.table_name, cb.ordinal_position
`

type GetColumnsForSchemaRow struct {
	TableSchema            interface{}    `db:"table_schema" json:"table_schema"`
	TableName              interface{}    `db:"table_name" json:"table_name"`
	ColumnName             interface{}    `db:"column_name" json:"column_name"`
	OrdinalPosition        interface{}    `db:"ordinal_position" json:"ordinal_position"`
	ColumnDefault          sql.NullString `db:"column_default" json:"column_default"`
	IsNullable             interface{}    `db:"is_nullable" json:"is_nullable"`
	DataType               interface{}    `db:"data_type" json:"data_type"`
	CharacterMaximumLength interface{}    `db:"character_maximum_length" json:"character_maximum_length"`
	NumericPrecision       interface{}    `db:"numeric_precision" json:"numeric_precision"`
	NumericScale           interface{}    `db:"numeric_scale" json:"numeric_scale"`
	UdtName                interface{}    `db:"udt_name" json:"udt_name"`
	ColumnComment          sql.NullString `db:"column_comment" json:"column_comment"`
	ResolvedType           sql.NullString `db:"resolved_type" json:"resolved_type"`
	IsIdentity             interface{}    `db:"is_identity" json:"is_identity"`
	IdentityGeneration     interface{}    `db:"identity_generation" json:"identity_generation"`
	IdentityStart          interface{}    `db:"identity_start" json:"identity_start"`
	IdentityIncrement      interface{}    `db:"identity_increment" json:"identity_increment"`
	IdentityMaximum        interface{}    `db:"identity_maximum" json:"identity_maximum"`
	IdentityMinimum        interface{}    `db:"identity_minimum" json:"identity_minimum"`
	IdentityCycle          interface{}    `db:"identity_cycle" json:"identity_cycle"`
	Attgenerated           interface{}    `db:"attgenerated" json:"attgenerated"`
	GeneratedExpr          sql.NullString `db:"generated_expr" json:"generated_expr"`
}

// GetColumnsForSchema retrieves all columns for tables in a specific schema
func (q *Queries) GetColumnsForSchema(ctx context.Context, tableSchema sql.NullString) ([]GetColumnsForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getColumnsForSchema, tableSchema)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetColumnsForSchemaRow
	for rows.Next() {
		var i GetColumnsForSchemaRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.ColumnName,
			&i.OrdinalPosition,
			&i.ColumnDefault,
			&i.IsNullable,
			&i.DataType,
			&i.CharacterMaximumLength,
			&i.NumericPrecision,
			&i.NumericScale,
			&i.UdtName,
			&i.ColumnComment,
			&i.ResolvedType,
			&i.IsIdentity,
			&i.IdentityGeneration,
			&i.IdentityStart,
			&i.IdentityIncrement,
			&i.IdentityMaximum,
			&i.IdentityMinimum,
			&i.IdentityCycle,
			&i.Attgenerated,
			&i.GeneratedExpr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompositeTypeColumns = `-- name: GetCompositeTypeColumns :many
SELECT 
    n.nspname AS type_schema,
    t.typname AS type_name,
    a.attname AS column_name,
    a.attnum AS column_position,
    format_type(a.atttypid, a.atttypmod) AS column_type
FROM pg_type t
JOIN pg_namespace n ON t.typnamespace = n.oid
JOIN pg_class c ON t.typrelid = c.oid
JOIN pg_attribute a ON c.oid = a.attrelid
WHERE t.typtype = 'c'  -- composite types only
    AND c.relkind = 'c'  -- only true composite types, not table types
    AND a.attnum > 0  -- exclude system columns
    AND NOT a.attisdropped  -- exclude dropped columns
    AND n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
ORDER BY n.nspname, t.typname, a.attnum
`

type GetCompositeTypeColumnsRow struct {
	TypeSchema     string         `db:"type_schema" json:"type_schema"`
	TypeName       string         `db:"type_name" json:"type_name"`
	ColumnName     string         `db:"column_name" json:"column_name"`
	ColumnPosition int16          `db:"column_position" json:"column_position"`
	ColumnType     sql.NullString `db:"column_type" json:"column_type"`
}

// GetCompositeTypeColumns retrieves columns for composite types
func (q *Queries) GetCompositeTypeColumns(ctx context.Context) ([]GetCompositeTypeColumnsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompositeTypeColumns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompositeTypeColumnsRow
	for rows.Next() {
		var i GetCompositeTypeColumnsRow
		if err := rows.Scan(
			&i.TypeSchema,
			&i.TypeName,
			&i.ColumnName,
			&i.ColumnPosition,
			&i.ColumnType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompositeTypeColumnsForSchema = `-- name: GetCompositeTypeColumnsForSchema :many
SELECT 
    n.nspname AS type_schema,
    t.typname AS type_name,
    a.attname AS column_name,
    a.attnum AS column_position,
    format_type(a.atttypid, a.atttypmod) AS column_type
FROM pg_type t
JOIN pg_namespace n ON t.typnamespace = n.oid
JOIN pg_class c ON t.typrelid = c.oid
JOIN pg_attribute a ON c.oid = a.attrelid
WHERE t.typtype = 'c'  -- composite types only
    AND c.relkind = 'c'  -- only true composite types, not table types
    AND a.attnum > 0  -- exclude system columns
    AND NOT a.attisdropped  -- exclude dropped columns
    AND n.nspname = $1
ORDER BY n.nspname, t.typname, a.attnum
`

type GetCompositeTypeColumnsForSchemaRow struct {
	TypeSchema     string         `db:"type_schema" json:"type_schema"`
	TypeName       string         `db:"type_name" json:"type_name"`
	ColumnName     string         `db:"column_name" json:"column_name"`
	ColumnPosition int16          `db:"column_position" json:"column_position"`
	ColumnType     sql.NullString `db:"column_type" json:"column_type"`
}

// GetCompositeTypeColumnsForSchema retrieves columns for composite types in a specific schema
func (q *Queries) GetCompositeTypeColumnsForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetCompositeTypeColumnsForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompositeTypeColumnsForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompositeTypeColumnsForSchemaRow
	for rows.Next() {
		var i GetCompositeTypeColumnsForSchemaRow
		if err := rows.Scan(
			&i.TypeSchema,
			&i.TypeName,
			&i.ColumnName,
			&i.ColumnPosition,
			&i.ColumnType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConstraints = `-- name: GetConstraints :many
SELECT 
    n.nspname AS table_schema,
    cl.relname AS table_name,
    c.conname AS constraint_name,
    CASE c.contype
        WHEN 'c' THEN 'CHECK'
        WHEN 'f' THEN 'FOREIGN KEY'
        WHEN 'p' THEN 'PRIMARY KEY'
        WHEN 'u' THEN 'UNIQUE'
        WHEN 'x' THEN 'EXCLUDE'
        ELSE 'UNKNOWN'
    END AS constraint_type,
    COALESCE(a.attname, '') AS column_name,
    COALESCE(a.attnum, 0) AS ordinal_position,
    COALESCE(fn.nspname, '') AS foreign_table_schema,
    COALESCE(fcl.relname, '') AS foreign_table_name,
    COALESCE(fa.attname, '') AS foreign_column_name,
    COALESCE(fa.attnum, 0) AS foreign_ordinal_position,
    CASE WHEN c.contype = 'c' THEN pg_get_constraintdef(c.oid, true) ELSE NULL END AS check_clause,
    CASE WHEN c.contype = 'x' THEN pg_get_constraintdef(c.oid, true) ELSE NULL END AS exclusion_definition,
    CASE c.confdeltype
        WHEN 'a' THEN 'NO ACTION'
        WHEN 'r' THEN 'RESTRICT'
        WHEN 'c' THEN 'CASCADE'
        WHEN 'n' THEN 'SET NULL'
        WHEN 'd' THEN 'SET DEFAULT'
        ELSE NULL
    END AS delete_rule,
    CASE c.confupdtype
        WHEN 'a' THEN 'NO ACTION'
        WHEN 'r' THEN 'RESTRICT'
        WHEN 'c' THEN 'CASCADE'
        WHEN 'n' THEN 'SET NULL'
        WHEN 'd' THEN 'SET DEFAULT'
        ELSE NULL
    END AS update_rule,
    c.condeferrable AS deferrable,
    c.condeferred AS initially_deferred,
    c.convalidated AS is_valid
FROM pg_constraint c
JOIN pg_class cl ON c.conrelid = cl.oid
JOIN pg_namespace n ON cl.relnamespace = n.oid
LEFT JOIN pg_attribute a ON a.attrelid = c.conrelid AND a.attnum = ANY(c.conkey)
LEFT JOIN pg_class fcl ON c.confrelid = fcl.oid
LEFT JOIN pg_namespace fn ON fcl.relnamespace = fn.oid
LEFT JOIN pg_attribute fa ON fa.attrelid = c.confrelid AND fa.attnum = c.confkey[array_position(c.conkey, a.attnum)]
WHERE n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
ORDER BY n.nspname, cl.relname, c.contype, c.conname, a.attnum
`

type GetConstraintsRow struct {
	TableSchema            string         `db:"table_schema" json:"table_schema"`
	TableName              string         `db:"table_name" json:"table_name"`
	ConstraintName         string         `db:"constraint_name" json:"constraint_name"`
	ConstraintType         sql.NullString `db:"constraint_type" json:"constraint_type"`
	ColumnName             sql.NullString `db:"column_name" json:"column_name"`
	OrdinalPosition        sql.NullInt32  `db:"ordinal_position" json:"ordinal_position"`
	ForeignTableSchema     sql.NullString `db:"foreign_table_schema" json:"foreign_table_schema"`
	ForeignTableName       sql.NullString `db:"foreign_table_name" json:"foreign_table_name"`
	ForeignColumnName      sql.NullString `db:"foreign_column_name" json:"foreign_column_name"`
	ForeignOrdinalPosition sql.NullInt32  `db:"foreign_ordinal_position" json:"foreign_ordinal_position"`
	CheckClause            sql.NullString `db:"check_clause" json:"check_clause"`
	ExclusionDefinition    sql.NullString `db:"exclusion_definition" json:"exclusion_definition"`
	DeleteRule             sql.NullString `db:"delete_rule" json:"delete_rule"`
	UpdateRule             sql.NullString `db:"update_rule" json:"update_rule"`
	Deferrable             bool           `db:"deferrable" json:"deferrable"`
	InitiallyDeferred      bool           `db:"initially_deferred" json:"initially_deferred"`
	IsValid                bool           `db:"is_valid" json:"is_valid"`
}

// GetConstraints retrieves all table constraints
func (q *Queries) GetConstraints(ctx context.Context) ([]GetConstraintsRow, error) {
	rows, err := q.db.QueryContext(ctx, getConstraints)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConstraintsRow
	for rows.Next() {
		var i GetConstraintsRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.ConstraintName,
			&i.ConstraintType,
			&i.ColumnName,
			&i.OrdinalPosition,
			&i.ForeignTableSchema,
			&i.ForeignTableName,
			&i.ForeignColumnName,
			&i.ForeignOrdinalPosition,
			&i.CheckClause,
			&i.ExclusionDefinition,
			&i.DeleteRule,
			&i.UpdateRule,
			&i.Deferrable,
			&i.InitiallyDeferred,
			&i.IsValid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConstraintsForSchema = `-- name: GetConstraintsForSchema :many
SELECT 
    n.nspname AS table_schema,
    cl.relname AS table_name,
    c.conname AS constraint_name,
    CASE c.contype
        WHEN 'c' THEN 'CHECK'
        WHEN 'f' THEN 'FOREIGN KEY'
        WHEN 'p' THEN 'PRIMARY KEY'
        WHEN 'u' THEN 'UNIQUE'
        WHEN 'x' THEN 'EXCLUDE'
        ELSE 'UNKNOWN'
    END AS constraint_type,
    COALESCE(a.attname, '') AS column_name,
    COALESCE(a.attnum, 0) AS ordinal_position,
    COALESCE(fn.nspname, '') AS foreign_table_schema,
    COALESCE(fcl.relname, '') AS foreign_table_name,
    COALESCE(fa.attname, '') AS foreign_column_name,
    COALESCE(fa.attnum, 0) AS foreign_ordinal_position,
    CASE WHEN c.contype = 'c' THEN pg_get_constraintdef(c.oid, true) ELSE NULL END AS check_clause,
    CASE WHEN c.contype = 'x' THEN pg_get_constraintdef(c.oid, true) ELSE NULL END AS exclusion_definition,
    CASE c.confdeltype
        WHEN 'a' THEN 'NO ACTION'
        WHEN 'r' THEN 'RESTRICT'
        WHEN 'c' THEN 'CASCADE'
        WHEN 'n' THEN 'SET NULL'
        WHEN 'd' THEN 'SET DEFAULT'
        ELSE NULL
    END AS delete_rule,
    CASE c.confupdtype
        WHEN 'a' THEN 'NO ACTION'
        WHEN 'r' THEN 'RESTRICT'
        WHEN 'c' THEN 'CASCADE'
        WHEN 'n' THEN 'SET NULL'
        WHEN 'd' THEN 'SET DEFAULT'
        ELSE NULL
    END AS update_rule,
    c.condeferrable AS deferrable,
    c.condeferred AS initially_deferred,
    c.convalidated AS is_valid
FROM pg_constraint c
JOIN pg_class cl ON c.conrelid = cl.oid
JOIN pg_namespace n ON cl.relnamespace = n.oid
LEFT JOIN pg_attribute a ON a.attrelid = c.conrelid AND a.attnum = ANY(c.conkey)
LEFT JOIN pg_class fcl ON c.confrelid = fcl.oid
LEFT JOIN pg_namespace fn ON fcl.relnamespace = fn.oid
LEFT JOIN pg_attribute fa ON fa.attrelid = c.confrelid AND fa.attnum = c.confkey[array_position(c.conkey, a.attnum)]
WHERE n.nspname = $1
ORDER BY n.nspname, cl.relname, c.contype, c.conname, a.attnum
`

type GetConstraintsForSchemaRow struct {
	TableSchema            string         `db:"table_schema" json:"table_schema"`
	TableName              string         `db:"table_name" json:"table_name"`
	ConstraintName         string         `db:"constraint_name" json:"constraint_name"`
	ConstraintType         sql.NullString `db:"constraint_type" json:"constraint_type"`
	ColumnName             sql.NullString `db:"column_name" json:"column_name"`
	OrdinalPosition        sql.NullInt32  `db:"ordinal_position" json:"ordinal_position"`
	ForeignTableSchema     sql.NullString `db:"foreign_table_schema" json:"foreign_table_schema"`
	ForeignTableName       sql.NullString `db:"foreign_table_name" json:"foreign_table_name"`
	ForeignColumnName      sql.NullString `db:"foreign_column_name" json:"foreign_column_name"`
	ForeignOrdinalPosition sql.NullInt32  `db:"foreign_ordinal_position" json:"foreign_ordinal_position"`
	CheckClause            sql.NullString `db:"check_clause" json:"check_clause"`
	ExclusionDefinition    sql.NullString `db:"exclusion_definition" json:"exclusion_definition"`
	DeleteRule             sql.NullString `db:"delete_rule" json:"delete_rule"`
	UpdateRule             sql.NullString `db:"update_rule" json:"update_rule"`
	Deferrable             bool           `db:"deferrable" json:"deferrable"`
	InitiallyDeferred      bool           `db:"initially_deferred" json:"initially_deferred"`
	IsValid                bool           `db:"is_valid" json:"is_valid"`
}

// GetConstraintsForSchema retrieves all table constraints for a specific schema
func (q *Queries) GetConstraintsForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetConstraintsForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getConstraintsForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConstraintsForSchemaRow
	for rows.Next() {
		var i GetConstraintsForSchemaRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.ConstraintName,
			&i.ConstraintType,
			&i.ColumnName,
			&i.OrdinalPosition,
			&i.ForeignTableSchema,
			&i.ForeignTableName,
			&i.ForeignColumnName,
			&i.ForeignOrdinalPosition,
			&i.CheckClause,
			&i.ExclusionDefinition,
			&i.DeleteRule,
			&i.UpdateRule,
			&i.Deferrable,
			&i.InitiallyDeferred,
			&i.IsValid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDefaultPrivilegesForSchema = `-- name: GetDefaultPrivilegesForSchema :many
WITH acl_expanded AS (
    SELECT
        d.defaclrole,
        d.defaclobjtype,
        (aclexplode(d.defaclacl)).grantee AS grantee_oid,
        (aclexplode(d.defaclacl)).privilege_type AS privilege_type,
        (aclexplode(d.defaclacl)).is_grantable AS is_grantable
    FROM pg_default_acl d
    JOIN pg_namespace n ON d.defaclnamespace = n.oid
    WHERE n.nspname = $1
)
SELECT
    pg_get_userbyid(a.defaclrole) AS owner_role,
    CASE a.defaclobjtype
        WHEN 'r' THEN 'TABLES'
        WHEN 'S' THEN 'SEQUENCES'
        WHEN 'f' THEN 'FUNCTIONS'
        WHEN 'T' THEN 'TYPES'
        WHEN 'n' THEN 'SCHEMAS'
    END AS object_type,
    COALESCE(r.rolname, 'PUBLIC') AS grantee,
    a.privilege_type,
    a.is_grantable
FROM acl_expanded a
LEFT JOIN pg_roles r ON a.grantee_oid = r.oid
ORDER BY owner_role, object_type, grantee, privilege_type
`

type GetDefaultPrivilegesForSchemaRow struct {
	OwnerRole     sql.NullString `db:"owner_role" json:"owner_role"`
	ObjectType    sql.NullString `db:"object_type" json:"object_type"`
	Grantee       sql.NullString `db:"grantee" json:"grantee"`
	PrivilegeType sql.NullString `db:"privilege_type" json:"privilege_type"`
	IsGrantable   sql.NullBool   `db:"is_grantable" json:"is_grantable"`
}

// GetDefaultPrivilegesForSchema retrieves default privileges for a specific schema
func (q *Queries) GetDefaultPrivilegesForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetDefaultPrivilegesForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getDefaultPrivilegesForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDefaultPrivilegesForSchemaRow
	for rows.Next() {
		var i GetDefaultPrivilegesForSchemaRow
		if err := rows.Scan(
			&i.OwnerRole,
			&i.ObjectType,
			&i.Grantee,
			&i.PrivilegeType,
			&i.IsGrantable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDomainConstraints = `-- name: GetDomainConstraints :many
SELECT 
    n.nspname AS domain_schema,
    t.typname AS domain_name,
    c.conname AS constraint_name,
    pg_get_constraintdef(c.oid, true) AS constraint_definition
FROM pg_constraint c
JOIN pg_type t ON c.contypid = t.oid
JOIN pg_namespace n ON t.typnamespace = n.oid
WHERE t.typtype = 'd'  -- Domain types only
    AND n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
ORDER BY n.nspname, t.typname, c.conname
`

type GetDomainConstraintsRow struct {
	DomainSchema         string         `db:"domain_schema" json:"domain_schema"`
	DomainName           string         `db:"domain_name" json:"domain_name"`
	ConstraintName       string         `db:"constraint_name" json:"constraint_name"`
	ConstraintDefinition sql.NullString `db:"constraint_definition" json:"constraint_definition"`
}

// GetDomainConstraints retrieves constraints for domains
func (q *Queries) GetDomainConstraints(ctx context.Context) ([]GetDomainConstraintsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDomainConstraints)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDomainConstraintsRow
	for rows.Next() {
		var i GetDomainConstraintsRow
		if err := rows.Scan(
			&i.DomainSchema,
			&i.DomainName,
			&i.ConstraintName,
			&i.ConstraintDefinition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDomainConstraintsForSchema = `-- name: GetDomainConstraintsForSchema :many
SELECT 
    n.nspname AS domain_schema,
    t.typname AS domain_name,
    c.conname AS constraint_name,
    pg_get_constraintdef(c.oid, true) AS constraint_definition
FROM pg_constraint c
JOIN pg_type t ON c.contypid = t.oid
JOIN pg_namespace n ON t.typnamespace = n.oid
WHERE t.typtype = 'd'  -- Domain types only
    AND n.nspname = $1
ORDER BY n.nspname, t.typname, c.conname
`

type GetDomainConstraintsForSchemaRow struct {
	DomainSchema         string         `db:"domain_schema" json:"domain_schema"`
	DomainName           string         `db:"domain_name" json:"domain_name"`
	ConstraintName       string         `db:"constraint_name" json:"constraint_name"`
	ConstraintDefinition sql.NullString `db:"constraint_definition" json:"constraint_definition"`
}

// GetDomainConstraintsForSchema retrieves constraints for domains in a specific schema
func (q *Queries) GetDomainConstraintsForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetDomainConstraintsForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getDomainConstraintsForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDomainConstraintsForSchemaRow
	for rows.Next() {
		var i GetDomainConstraintsForSchemaRow
		if err := rows.Scan(
			&i.DomainSchema,
			&i.DomainName,
			&i.ConstraintName,
			&i.ConstraintDefinition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDomains = `-- name: GetDomains :many
SELECT 
    n.nspname AS domain_schema,
    t.typname AS domain_name,
    format_type(t.typbasetype, t.typtypmod) AS base_type,
    t.typnotnull AS not_null,
    t.typdefault AS default_value,
    COALESCE(d.description, '') AS domain_comment
FROM pg_type t
JOIN pg_namespace n ON t.typnamespace = n.oid
LEFT JOIN pg_description d ON d.objoid = t.oid AND d.classoid = 'pg_type'::regclass
WHERE t.typtype = 'd'  -- Domain types only
    AND n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
ORDER BY n.nspname, t.typname
`

type GetDomainsRow struct {
	DomainSchema  string         `db:"domain_schema" json:"domain_schema"`
	DomainName    string         `db:"domain_name" json:"domain_name"`
	BaseType      sql.NullString `db:"base_type" json:"base_type"`
	NotNull       bool           `db:"not_null" json:"not_null"`
	DefaultValue  sql.NullString `db:"default_value" json:"default_value"`
	DomainComment sql.NullString `db:"domain_comment" json:"domain_comment"`
}

// GetDomains retrieves all user-defined domains
func (q *Queries) GetDomains(ctx context.Context) ([]GetDomainsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDomains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDomainsRow
	for rows.Next() {
		var i GetDomainsRow
		if err := rows.Scan(
			&i.DomainSchema,
			&i.DomainName,
			&i.BaseType,
			&i.NotNull,
			&i.DefaultValue,
			&i.DomainComment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDomainsForSchema = `-- name: GetDomainsForSchema :many
SELECT 
    n.nspname AS domain_schema,
    t.typname AS domain_name,
    format_type(t.typbasetype, t.typtypmod) AS base_type,
    t.typnotnull AS not_null,
    t.typdefault AS default_value,
    COALESCE(d.description, '') AS domain_comment
FROM pg_type t
JOIN pg_namespace n ON t.typnamespace = n.oid
LEFT JOIN pg_description d ON d.objoid = t.oid AND d.classoid = 'pg_type'::regclass
WHERE t.typtype = 'd'  -- Domain types only
    AND n.nspname = $1
ORDER BY n.nspname, t.typname
`

type GetDomainsForSchemaRow struct {
	DomainSchema  string         `db:"domain_schema" json:"domain_schema"`
	DomainName    string         `db:"domain_name" json:"domain_name"`
	BaseType      sql.NullString `db:"base_type" json:"base_type"`
	NotNull       bool           `db:"not_null" json:"not_null"`
	DefaultValue  sql.NullString `db:"default_value" json:"default_value"`
	DomainComment sql.NullString `db:"domain_comment" json:"domain_comment"`
}

// GetDomainsForSchema retrieves all user-defined domains for a specific schema
func (q *Queries) GetDomainsForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetDomainsForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getDomainsForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDomainsForSchemaRow
	for rows.Next() {
		var i GetDomainsForSchemaRow
		if err := rows.Scan(
			&i.DomainSchema,
			&i.DomainName,
			&i.BaseType,
			&i.NotNull,
			&i.DefaultValue,
			&i.DomainComment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnumValues = `-- name: GetEnumValues :many
SELECT 
    n.nspname AS type_schema,
    t.typname AS type_name,
    e.enumlabel AS enum_value,
    e.enumsortorder AS enum_order
FROM pg_enum e
JOIN pg_type t ON e.enumtypid = t.oid
JOIN pg_namespace n ON t.typnamespace = n.oid
WHERE n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
ORDER BY n.nspname, t.typname, e.enumsortorder
`

type GetEnumValuesRow struct {
	TypeSchema string  `db:"type_schema" json:"type_schema"`
	TypeName   string  `db:"type_name" json:"type_name"`
	EnumValue  string  `db:"enum_value" json:"enum_value"`
	EnumOrder  float32 `db:"enum_order" json:"enum_order"`
}

// GetEnumValues retrieves enum values for ENUM types
func (q *Queries) GetEnumValues(ctx context.Context) ([]GetEnumValuesRow, error) {
	rows, err := q.db.QueryContext(ctx, getEnumValues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEnumValuesRow
	for rows.Next() {
		var i GetEnumValuesRow
		if err := rows.Scan(
			&i.TypeSchema,
			&i.TypeName,
			&i.EnumValue,
			&i.EnumOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnumValuesForSchema = `-- name: GetEnumValuesForSchema :many
SELECT 
    n.nspname AS type_schema,
    t.typname AS type_name,
    e.enumlabel AS enum_value,
    e.enumsortorder AS enum_order
FROM pg_enum e
JOIN pg_type t ON e.enumtypid = t.oid
JOIN pg_namespace n ON t.typnamespace = n.oid
WHERE n.nspname = $1
ORDER BY n.nspname, t.typname, e.enumsortorder
`

type GetEnumValuesForSchemaRow struct {
	TypeSchema string  `db:"type_schema" json:"type_schema"`
	TypeName   string  `db:"type_name" json:"type_name"`
	EnumValue  string  `db:"enum_value" json:"enum_value"`
	EnumOrder  float32 `db:"enum_order" json:"enum_order"`
}

// GetEnumValuesForSchema retrieves enum values for ENUM types in a specific schema
func (q *Queries) GetEnumValuesForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetEnumValuesForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getEnumValuesForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEnumValuesForSchemaRow
	for rows.Next() {
		var i GetEnumValuesForSchemaRow
		if err := rows.Scan(
			&i.TypeSchema,
			&i.TypeName,
			&i.EnumValue,
			&i.EnumOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFunctions = `-- name: GetFunctions :many
SELECT
    r.routine_schema,
    r.routine_name,
    p.prosrc AS routine_definition,
    r.routine_type,
    COALESCE(pg_get_function_result(p.oid), r.data_type) AS data_type,
    r.external_language,
    COALESCE(desc_func.description, '') AS function_comment,
    oidvectortypes(p.proargtypes) AS function_arguments,
    pg_get_function_arguments(p.oid) AS function_signature,
    CASE p.provolatile
        WHEN 'i' THEN 'IMMUTABLE'
        WHEN 's' THEN 'STABLE'
        WHEN 'v' THEN 'VOLATILE'
        ELSE NULL
    END AS volatility,
    p.proisstrict AS is_strict,
    p.prosecdef AS is_security_definer
FROM information_schema.routines r
LEFT JOIN pg_proc p ON p.proname = r.routine_name 
    AND p.pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = r.routine_schema)
LEFT JOIN pg_depend d ON d.objid = p.oid AND d.deptype = 'e'
LEFT JOIN pg_description desc_func ON desc_func.objoid = p.oid AND desc_func.classoid = 'pg_proc'::regclass
WHERE 
    r.routine_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND r.routine_schema NOT LIKE 'pg_temp_%'
    AND r.routine_schema NOT LIKE 'pg_toast_temp_%'
    AND r.routine_type = 'FUNCTION'
    AND d.objid IS NULL  -- Exclude functions that are extension members
ORDER BY r.routine_schema, r.routine_name
`

type GetFunctionsRow struct {
	RoutineSchema     interface{}    `db:"routine_schema" json:"routine_schema"`
	RoutineName       interface{}    `db:"routine_name" json:"routine_name"`
	RoutineDefinition string         `db:"routine_definition" json:"routine_definition"`
	RoutineType       interface{}    `db:"routine_type" json:"routine_type"`
	DataType          sql.NullString `db:"data_type" json:"data_type"`
	ExternalLanguage  interface{}    `db:"external_language" json:"external_language"`
	FunctionComment   sql.NullString `db:"function_comment" json:"function_comment"`
	FunctionArguments sql.NullString `db:"function_arguments" json:"function_arguments"`
	FunctionSignature sql.NullString `db:"function_signature" json:"function_signature"`
	Volatility        sql.NullString `db:"volatility" json:"volatility"`
	IsStrict          bool           `db:"is_strict" json:"is_strict"`
	IsSecurityDefiner bool           `db:"is_security_definer" json:"is_security_definer"`
}

// GetFunctions retrieves all user-defined functions (excluding extension members)
func (q *Queries) GetFunctions(ctx context.Context) ([]GetFunctionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFunctions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFunctionsRow
	for rows.Next() {
		var i GetFunctionsRow
		if err := rows.Scan(
			&i.RoutineSchema,
			&i.RoutineName,
			&i.RoutineDefinition,
			&i.RoutineType,
			&i.DataType,
			&i.ExternalLanguage,
			&i.FunctionComment,
			&i.FunctionArguments,
			&i.FunctionSignature,
			&i.Volatility,
			&i.IsStrict,
			&i.IsSecurityDefiner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFunctionsForSchema = `-- name: GetFunctionsForSchema :many
SELECT
    r.routine_schema,
    r.routine_name,
    -- Use pg_get_function_sqlbody for RETURN clause syntax (PG14+)
    -- Fall back to prosrc for traditional AS $$ ... $$ syntax
    COALESCE(
        pg_get_function_sqlbody(p.oid),
        CASE WHEN p.prosrc ~ E'\n$' THEN p.prosrc ELSE p.prosrc || E'\n' END
    ) AS routine_definition,
    r.routine_type,
    COALESCE(pg_get_function_result(p.oid), r.data_type) AS data_type,
    r.external_language,
    COALESCE(desc_func.description, '') AS function_comment,
    oidvectortypes(p.proargtypes) AS function_arguments,
    pg_get_function_arguments(p.oid) AS function_signature,
    CASE p.provolatile
        WHEN 'i' THEN 'IMMUTABLE'
        WHEN 's' THEN 'STABLE'
        WHEN 'v' THEN 'VOLATILE'
        ELSE NULL
    END AS volatility,
    p.proisstrict AS is_strict,
    p.prosecdef AS is_security_definer,
    p.proleakproof AS is_leakproof,
    p.proparallel AS parallel_mode,
    (SELECT substring(cfg FROM 'search_path=(.*)') FROM unnest(p.proconfig) AS cfg WHERE cfg LIKE 'search_path=%') AS search_path
FROM information_schema.routines r
LEFT JOIN pg_proc p ON p.proname = r.routine_name
    AND p.pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = r.routine_schema)
LEFT JOIN pg_depend d ON d.objid = p.oid AND d.deptype = 'e'
LEFT JOIN pg_description desc_func ON desc_func.objoid = p.oid AND desc_func.classoid = 'pg_proc'::regclass
WHERE r.routine_schema = $1
    AND r.routine_type = 'FUNCTION'
    AND d.objid IS NULL  -- Exclude functions that are extension members
ORDER BY r.routine_schema, r.routine_name
`

type GetFunctionsForSchemaRow struct {
	RoutineSchema     interface{}    `db:"routine_schema" json:"routine_schema"`
	RoutineName       interface{}    `db:"routine_name" json:"routine_name"`
	RoutineDefinition sql.NullString `db:"routine_definition" json:"routine_definition"`
	RoutineType       interface{}    `db:"routine_type" json:"routine_type"`
	DataType          sql.NullString `db:"data_type" json:"data_type"`
	ExternalLanguage  interface{}    `db:"external_language" json:"external_language"`
	FunctionComment   sql.NullString `db:"function_comment" json:"function_comment"`
	FunctionArguments sql.NullString `db:"function_arguments" json:"function_arguments"`
	FunctionSignature sql.NullString `db:"function_signature" json:"function_signature"`
	Volatility        sql.NullString `db:"volatility" json:"volatility"`
	IsStrict          bool           `db:"is_strict" json:"is_strict"`
	IsSecurityDefiner bool           `db:"is_security_definer" json:"is_security_definer"`
	IsLeakproof       bool           `db:"is_leakproof" json:"is_leakproof"`
	ParallelMode      interface{}    `db:"parallel_mode" json:"parallel_mode"`
	SearchPath        sql.NullString `db:"search_path" json:"search_path"`
}

// GetFunctionsForSchema retrieves all user-defined functions for a specific schema
func (q *Queries) GetFunctionsForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetFunctionsForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getFunctionsForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFunctionsForSchemaRow
	for rows.Next() {
		var i GetFunctionsForSchemaRow
		if err := rows.Scan(
			&i.RoutineSchema,
			&i.RoutineName,
			&i.RoutineDefinition,
			&i.RoutineType,
			&i.DataType,
			&i.ExternalLanguage,
			&i.FunctionComment,
			&i.FunctionArguments,
			&i.FunctionSignature,
			&i.Volatility,
			&i.IsStrict,
			&i.IsSecurityDefiner,
			&i.IsLeakproof,
			&i.ParallelMode,
			&i.SearchPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndexes = `-- name: GetIndexes :many
WITH index_base AS (
    SELECT
        n.nspname as schemaname,
        t.relname as tablename,
        i.relname as indexname,
        idx.indisunique as is_unique,
        idx.indisprimary as is_primary,
        (idx.indpred IS NOT NULL) as is_partial,
        am.amname as method,
        pg_get_indexdef(idx.indexrelid) as indexdef,
        idx.indpred,
        idx.indrelid,
        CASE
            WHEN idx.indexprs IS NOT NULL THEN true
            ELSE false
        END as has_expressions
    FROM pg_index idx
    JOIN pg_class i ON i.oid = idx.indexrelid
    JOIN pg_class t ON t.oid = idx.indrelid
    JOIN pg_namespace n ON n.oid = t.relnamespace
    JOIN pg_am am ON am.oid = i.relam
    WHERE
        NOT idx.indisprimary
        AND NOT EXISTS (
            SELECT 1 FROM pg_constraint c
            WHERE c.conindid = idx.indexrelid
            AND c.contype IN ('u', 'p', 'x')
        )
        AND n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
        AND n.nspname NOT LIKE 'pg_temp_%'
        AND n.nspname NOT LIKE 'pg_toast_temp_%'
)
SELECT
    ib.schemaname,
    ib.tablename,
    ib.indexname,
    ib.is_unique,
    ib.is_primary,
    ib.is_partial,
    ib.method,
    ib.indexdef,
    -- Use LATERAL join to guarantee execution order:
    -- 1. set_config sets search_path to empty (like pg_dump does)
    -- 2. pg_get_expr then uses that search_path
    -- This ensures type references are schema-qualified (e.g., 'value'::public.my_enum)
    sp.partial_predicate,
    ib.has_expressions
FROM index_base ib
CROSS JOIN LATERAL (
    SELECT
        set_config('search_path', '', true) as dummy,
        CASE
            WHEN ib.indpred IS NOT NULL THEN pg_get_expr(ib.indpred, ib.indrelid)
            ELSE NULL
        END as partial_predicate
) sp
ORDER BY ib.schemaname, ib.tablename, ib.indexname
`

type GetIndexesRow struct {
	Schemaname       string         `db:"schemaname" json:"schemaname"`
	Tablename        string         `db:"tablename" json:"tablename"`
	Indexname        string         `db:"indexname" json:"indexname"`
	IsUnique         bool           `db:"is_unique" json:"is_unique"`
	IsPrimary        bool           `db:"is_primary" json:"is_primary"`
	IsPartial        sql.NullBool   `db:"is_partial" json:"is_partial"`
	Method           string         `db:"method" json:"method"`
	Indexdef         sql.NullString `db:"indexdef" json:"indexdef"`
	PartialPredicate sql.NullString `db:"partial_predicate" json:"partial_predicate"`
	HasExpressions   sql.NullBool   `db:"has_expressions" json:"has_expressions"`
}

// GetIndexes retrieves all indexes including regular and unique indexes created with CREATE INDEX
// IMPORTANT: Uses LATERAL join with set_config to temporarily set search_path to empty
// This ensures pg_get_expr() includes schema qualifiers for types in partial index predicates,
// matching pg_dump's behavior and preventing false positives when comparing schemas
func (q *Queries) GetIndexes(ctx context.Context) ([]GetIndexesRow, error) {
	rows, err := q.db.QueryContext(ctx, getIndexes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIndexesRow
	for rows.Next() {
		var i GetIndexesRow
		if err := rows.Scan(
			&i.Schemaname,
			&i.Tablename,
			&i.Indexname,
			&i.IsUnique,
			&i.IsPrimary,
			&i.IsPartial,
			&i.Method,
			&i.Indexdef,
			&i.PartialPredicate,
			&i.HasExpressions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndexesForSchema = `-- name: GetIndexesForSchema :many
WITH index_base AS (
    SELECT
        n.nspname as schemaname,
        t.relname as tablename,
        i.relname as indexname,
        idx.indisunique as is_unique,
        idx.indisprimary as is_primary,
        (idx.indpred IS NOT NULL) as is_partial,
        am.amname as method,
        pg_get_indexdef(idx.indexrelid) as indexdef,
        idx.indpred,
        idx.indrelid,
        CASE
            WHEN idx.indexprs IS NOT NULL THEN true
            ELSE false
        END as has_expressions,
        COALESCE(d.description, '') AS index_comment,
        idx.indnatts as num_columns,
        ARRAY(
            SELECT pg_get_indexdef(idx.indexrelid, k::int, true)
            FROM generate_series(1, idx.indnatts) k
        ) as column_definitions,
        ARRAY(
            SELECT
                CASE
                    WHEN (idx.indoption[k-1] & 1) = 1 THEN 'DESC'
                    ELSE 'ASC'
                END
            FROM generate_series(1, idx.indnatts) k
        ) as column_directions,
        ARRAY(
            SELECT CASE
                WHEN opc.opcdefault THEN ''  -- Omit default operator classes
                ELSE COALESCE(opc.opcname, '')
            END
            FROM generate_series(1, idx.indnatts) k
            LEFT JOIN pg_opclass opc ON opc.oid = idx.indclass[k-1]
        ) as column_opclasses
    FROM pg_index idx
    JOIN pg_class i ON i.oid = idx.indexrelid
    JOIN pg_class t ON t.oid = idx.indrelid
    JOIN pg_namespace n ON n.oid = t.relnamespace
    JOIN pg_am am ON am.oid = i.relam
    LEFT JOIN pg_description d ON d.objoid = i.oid AND d.objsubid = 0
    WHERE
        NOT idx.indisprimary
        AND NOT EXISTS (
            SELECT 1 FROM pg_constraint c
            WHERE c.conindid = idx.indexrelid
            AND c.contype IN ('u', 'p', 'x')
        )
        AND n.nspname = $1
)
SELECT
    ib.schemaname,
    ib.tablename,
    ib.indexname,
    ib.is_unique,
    ib.is_primary,
    ib.is_partial,
    ib.method,
    ib.indexdef,
    -- Use LATERAL join to guarantee execution order:
    -- 1. set_config sets search_path to empty (like pg_dump does)
    -- 2. pg_get_expr then uses that search_path
    -- This ensures type references are schema-qualified (e.g., 'value'::public.my_enum)
    sp.partial_predicate,
    ib.has_expressions,
    ib.index_comment,
    ib.num_columns,
    ib.column_definitions,
    ib.column_directions,
    ib.column_opclasses
FROM index_base ib
CROSS JOIN LATERAL (
    SELECT
        set_config('search_path', '', true) as dummy,
        CASE
            WHEN ib.indpred IS NOT NULL THEN pg_get_expr(ib.indpred, ib.indrelid)
            ELSE NULL
        END as partial_predicate
) sp
ORDER BY ib.schemaname, ib.tablename, ib.indexname
`

type GetIndexesForSchemaRow struct {
	Schemaname        string         `db:"schemaname" json:"schemaname"`
	Tablename         string         `db:"tablename" json:"tablename"`
	Indexname         string         `db:"indexname" json:"indexname"`
	IsUnique          bool           `db:"is_unique" json:"is_unique"`
	IsPrimary         bool           `db:"is_primary" json:"is_primary"`
	IsPartial         sql.NullBool   `db:"is_partial" json:"is_partial"`
	Method            string         `db:"method" json:"method"`
	Indexdef          sql.NullString `db:"indexdef" json:"indexdef"`
	PartialPredicate  sql.NullString `db:"partial_predicate" json:"partial_predicate"`
	HasExpressions    sql.NullBool   `db:"has_expressions" json:"has_expressions"`
	IndexComment      sql.NullString `db:"index_comment" json:"index_comment"`
	NumColumns        int16          `db:"num_columns" json:"num_columns"`
	ColumnDefinitions []string       `db:"column_definitions" json:"column_definitions"`
	ColumnDirections  []string       `db:"column_directions" json:"column_directions"`
	ColumnOpclasses   []string       `db:"column_opclasses" json:"column_opclasses"`
}

// GetIndexesForSchema retrieves all indexes for a specific schema
// IMPORTANT: Uses LATERAL join with set_config to temporarily set search_path to empty
// This ensures pg_get_expr() includes schema qualifiers for types in partial index predicates,
// matching pg_dump's behavior and preventing false positives when comparing schemas
func (q *Queries) GetIndexesForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetIndexesForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getIndexesForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIndexesForSchemaRow
	for rows.Next() {
		var i GetIndexesForSchemaRow
		if err := rows.Scan(
			&i.Schemaname,
			&i.Tablename,
			&i.Indexname,
			&i.IsUnique,
			&i.IsPrimary,
			&i.IsPartial,
			&i.Method,
			&i.Indexdef,
			&i.PartialPredicate,
			&i.HasExpressions,
			&i.IndexComment,
			&i.NumColumns,
			pq.Array(&i.ColumnDefinitions),
			pq.Array(&i.ColumnDirections),
			pq.Array(&i.ColumnOpclasses),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPartitionChildren = `-- name: GetPartitionChildren :many
SELECT 
    pn.nspname AS parent_schema,
    pc.relname AS parent_table,
    cn.nspname AS child_schema,
    cc.relname AS child_table,
    pg_get_expr(cc.relpartbound, cc.oid) AS partition_bound
FROM pg_inherits inh
JOIN pg_class pc ON inh.inhparent = pc.oid
JOIN pg_namespace pn ON pc.relnamespace = pn.oid
JOIN pg_class cc ON inh.inhrelid = cc.oid
JOIN pg_namespace cn ON cc.relnamespace = cn.oid
WHERE pn.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND pn.nspname NOT LIKE 'pg_temp_%'
    AND pn.nspname NOT LIKE 'pg_toast_temp_%'
    AND cn.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND cn.nspname NOT LIKE 'pg_temp_%'
    AND cn.nspname NOT LIKE 'pg_toast_temp_%'
    AND EXISTS (
        SELECT 1 FROM pg_partitioned_table pt 
        WHERE pt.partrelid = pc.oid
    )
ORDER BY pn.nspname, pc.relname, cn.nspname, cc.relname
`

type GetPartitionChildrenRow struct {
	ParentSchema   string         `db:"parent_schema" json:"parent_schema"`
	ParentTable    string         `db:"parent_table" json:"parent_table"`
	ChildSchema    string         `db:"child_schema" json:"child_schema"`
	ChildTable     string         `db:"child_table" json:"child_table"`
	PartitionBound sql.NullString `db:"partition_bound" json:"partition_bound"`
}

// GetPartitionChildren retrieves partition child tables and their attachment information
func (q *Queries) GetPartitionChildren(ctx context.Context) ([]GetPartitionChildrenRow, error) {
	rows, err := q.db.QueryContext(ctx, getPartitionChildren)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPartitionChildrenRow
	for rows.Next() {
		var i GetPartitionChildrenRow
		if err := rows.Scan(
			&i.ParentSchema,
			&i.ParentTable,
			&i.ChildSchema,
			&i.ChildTable,
			&i.PartitionBound,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPartitionedTablesForSchema = `-- name: GetPartitionedTablesForSchema :many
SELECT 
    n.nspname AS table_schema,
    c.relname AS table_name,
    CASE pt.partstrat
        WHEN 'r' THEN 'RANGE'
        WHEN 'l' THEN 'LIST'
        WHEN 'h' THEN 'HASH'
        ELSE 'UNKNOWN'
    END AS partition_strategy,
    STRING_AGG(a.attname, ', ' ORDER BY a.attnum) AS partition_key
FROM pg_partitioned_table pt
JOIN pg_class c ON pt.partrelid = c.oid
JOIN pg_namespace n ON c.relnamespace = n.oid
JOIN pg_attribute a ON a.attrelid = pt.partrelid AND a.attnum = ANY(pt.partattrs)
WHERE n.nspname = $1
GROUP BY n.nspname, c.relname, pt.partstrat
ORDER BY n.nspname, c.relname
`

type GetPartitionedTablesForSchemaRow struct {
	TableSchema       string         `db:"table_schema" json:"table_schema"`
	TableName         string         `db:"table_name" json:"table_name"`
	PartitionStrategy sql.NullString `db:"partition_strategy" json:"partition_strategy"`
	PartitionKey      sql.NullString `db:"partition_key" json:"partition_key"`
}

// GetPartitionedTablesForSchema retrieves partition information for partitioned tables in a specific schema
func (q *Queries) GetPartitionedTablesForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetPartitionedTablesForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getPartitionedTablesForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPartitionedTablesForSchemaRow
	for rows.Next() {
		var i GetPartitionedTablesForSchemaRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.PartitionStrategy,
			&i.PartitionKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrivilegesForSchema = `-- name: GetPrivilegesForSchema :many
WITH acl_data AS (
    -- Tables and Views
    SELECT
        n.nspname AS schema_name,
        c.relname::text AS object_name,
        CASE c.relkind
            WHEN 'r' THEN 'TABLE'
            WHEN 'v' THEN 'VIEW'
            WHEN 'm' THEN 'VIEW'
            WHEN 'S' THEN 'SEQUENCE'
        END AS object_type,
        c.relacl AS acl,
        pg_get_userbyid(c.relowner) AS owner
    FROM pg_class c
    JOIN pg_namespace n ON c.relnamespace = n.oid
    WHERE n.nspname = $1
        AND c.relkind IN ('r', 'v', 'm', 'S')
        AND c.relacl IS NOT NULL

    UNION ALL

    -- Functions
    SELECT
        n.nspname AS schema_name,
        p.proname || '(' || pg_get_function_identity_arguments(p.oid) || ')' AS object_name,
        'FUNCTION' AS object_type,
        p.proacl AS acl,
        pg_get_userbyid(p.proowner) AS owner
    FROM pg_proc p
    JOIN pg_namespace n ON p.pronamespace = n.oid
    WHERE n.nspname = $1
        AND p.prokind = 'f'
        AND p.proacl IS NOT NULL

    UNION ALL

    -- Procedures
    SELECT
        n.nspname AS schema_name,
        p.proname || '(' || pg_get_function_identity_arguments(p.oid) || ')' AS object_name,
        'PROCEDURE' AS object_type,
        p.proacl AS acl,
        pg_get_userbyid(p.proowner) AS owner
    FROM pg_proc p
    JOIN pg_namespace n ON p.pronamespace = n.oid
    WHERE n.nspname = $1
        AND p.prokind = 'p'
        AND p.proacl IS NOT NULL

    UNION ALL

    -- Types (ENUM, COMPOSITE, DOMAIN)
    SELECT
        n.nspname AS schema_name,
        t.typname::text AS object_name,
        'TYPE' AS object_type,
        t.typacl AS acl,
        pg_get_userbyid(t.typowner) AS owner
    FROM pg_type t
    JOIN pg_namespace n ON t.typnamespace = n.oid
    WHERE n.nspname = $1
        AND t.typtype IN ('e', 'c', 'd')
        AND t.typacl IS NOT NULL
)
SELECT
    schema_name,
    object_name,
    object_type,
    (aclexplode(acl)).grantee AS grantee_oid,
    (aclexplode(acl)).privilege_type AS privilege_type,
    (aclexplode(acl)).is_grantable AS is_grantable,
    owner
FROM acl_data
ORDER BY object_type, object_name, grantee_oid, privilege_type
`

type GetPrivilegesForSchemaRow struct {
	SchemaName    sql.NullString `db:"schema_name" json:"schema_name"`
	ObjectName    sql.NullString `db:"object_name" json:"object_name"`
	ObjectType    sql.NullString `db:"object_type" json:"object_type"`
	GranteeOid    interface{}    `db:"grantee_oid" json:"grantee_oid"`
	PrivilegeType sql.NullString `db:"privilege_type" json:"privilege_type"`
	IsGrantable   sql.NullBool   `db:"is_grantable" json:"is_grantable"`
	Owner         sql.NullString `db:"owner" json:"owner"`
}

// GetPrivilegesForSchema retrieves explicit privilege grants for objects in a specific schema
func (q *Queries) GetPrivilegesForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetPrivilegesForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrivilegesForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPrivilegesForSchemaRow
	for rows.Next() {
		var i GetPrivilegesForSchemaRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.ObjectName,
			&i.ObjectType,
			&i.GranteeOid,
			&i.PrivilegeType,
			&i.IsGrantable,
			&i.Owner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcedures = `-- name: GetProcedures :many
SELECT
    r.routine_schema,
    r.routine_name,
    p.prosrc AS routine_definition,
    r.routine_type,
    r.external_language,
    COALESCE(desc_proc.description, '') AS procedure_comment,
    oidvectortypes(p.proargtypes) AS procedure_arguments,
    pg_get_function_arguments(p.oid) AS procedure_signature
FROM information_schema.routines r
LEFT JOIN pg_proc p ON p.proname = r.routine_name 
    AND p.pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = r.routine_schema)
LEFT JOIN pg_depend d ON d.objid = p.oid AND d.deptype = 'e'
LEFT JOIN pg_description desc_proc ON desc_proc.objoid = p.oid AND desc_proc.classoid = 'pg_proc'::regclass
WHERE 
    r.routine_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND r.routine_schema NOT LIKE 'pg_temp_%'
    AND r.routine_schema NOT LIKE 'pg_toast_temp_%'
    AND r.routine_type = 'PROCEDURE'
    AND d.objid IS NULL  -- Exclude procedures that are extension members
ORDER BY r.routine_schema, r.routine_name
`

type GetProceduresRow struct {
	RoutineSchema      interface{}    `db:"routine_schema" json:"routine_schema"`
	RoutineName        interface{}    `db:"routine_name" json:"routine_name"`
	RoutineDefinition  string         `db:"routine_definition" json:"routine_definition"`
	RoutineType        interface{}    `db:"routine_type" json:"routine_type"`
	ExternalLanguage   interface{}    `db:"external_language" json:"external_language"`
	ProcedureComment   sql.NullString `db:"procedure_comment" json:"procedure_comment"`
	ProcedureArguments sql.NullString `db:"procedure_arguments" json:"procedure_arguments"`
	ProcedureSignature sql.NullString `db:"procedure_signature" json:"procedure_signature"`
}

// GetProcedures retrieves all user-defined procedures (excluding extension members)
func (q *Queries) GetProcedures(ctx context.Context) ([]GetProceduresRow, error) {
	rows, err := q.db.QueryContext(ctx, getProcedures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProceduresRow
	for rows.Next() {
		var i GetProceduresRow
		if err := rows.Scan(
			&i.RoutineSchema,
			&i.RoutineName,
			&i.RoutineDefinition,
			&i.RoutineType,
			&i.ExternalLanguage,
			&i.ProcedureComment,
			&i.ProcedureArguments,
			&i.ProcedureSignature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProceduresForSchema = `-- name: GetProceduresForSchema :many
SELECT
    r.routine_schema,
    r.routine_name,
    -- Use pg_get_function_sqlbody for RETURN clause syntax (PG14+)
    -- Fall back to prosrc for traditional AS $$ ... $$ syntax
    COALESCE(
        pg_get_function_sqlbody(p.oid),
        CASE WHEN p.prosrc ~ E'\n$' THEN p.prosrc ELSE p.prosrc || E'\n' END
    ) AS routine_definition,
    r.routine_type,
    r.external_language,
    COALESCE(desc_proc.description, '') AS procedure_comment,
    oidvectortypes(p.proargtypes) AS procedure_arguments,
    pg_get_function_arguments(p.oid) AS procedure_signature
FROM information_schema.routines r
LEFT JOIN pg_proc p ON p.proname = r.routine_name
    AND p.pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = r.routine_schema)
LEFT JOIN pg_depend d ON d.objid = p.oid AND d.deptype = 'e'
LEFT JOIN pg_description desc_proc ON desc_proc.objoid = p.oid AND desc_proc.classoid = 'pg_proc'::regclass
WHERE r.routine_schema = $1
    AND r.routine_type = 'PROCEDURE'
    AND d.objid IS NULL  -- Exclude procedures that are extension members
ORDER BY r.routine_schema, r.routine_name
`

type GetProceduresForSchemaRow struct {
	RoutineSchema      interface{}    `db:"routine_schema" json:"routine_schema"`
	RoutineName        interface{}    `db:"routine_name" json:"routine_name"`
	RoutineDefinition  sql.NullString `db:"routine_definition" json:"routine_definition"`
	RoutineType        interface{}    `db:"routine_type" json:"routine_type"`
	ExternalLanguage   interface{}    `db:"external_language" json:"external_language"`
	ProcedureComment   sql.NullString `db:"procedure_comment" json:"procedure_comment"`
	ProcedureArguments sql.NullString `db:"procedure_arguments" json:"procedure_arguments"`
	ProcedureSignature sql.NullString `db:"procedure_signature" json:"procedure_signature"`
}

// GetProceduresForSchema retrieves all user-defined procedures for a specific schema
func (q *Queries) GetProceduresForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetProceduresForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getProceduresForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProceduresForSchemaRow
	for rows.Next() {
		var i GetProceduresForSchemaRow
		if err := rows.Scan(
			&i.RoutineSchema,
			&i.RoutineName,
			&i.RoutineDefinition,
			&i.RoutineType,
			&i.ExternalLanguage,
			&i.ProcedureComment,
			&i.ProcedureArguments,
			&i.ProcedureSignature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRLSPolicies = `-- name: GetRLSPolicies :many
SELECT 
    schemaname,
    tablename,
    policyname,
    permissive,
    roles,
    cmd,
    qual,
    with_check
FROM pg_policies
WHERE 
    schemaname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND schemaname NOT LIKE 'pg_temp_%'
    AND schemaname NOT LIKE 'pg_toast_temp_%'
ORDER BY schemaname, tablename, policyname
`

type GetRLSPoliciesRow struct {
	Schemaname sql.NullString `db:"schemaname" json:"schemaname"`
	Tablename  sql.NullString `db:"tablename" json:"tablename"`
	Policyname sql.NullString `db:"policyname" json:"policyname"`
	Permissive sql.NullString `db:"permissive" json:"permissive"`
	Roles      []string       `db:"roles" json:"roles"`
	Cmd        sql.NullString `db:"cmd" json:"cmd"`
	Qual       sql.NullString `db:"qual" json:"qual"`
	WithCheck  sql.NullString `db:"with_check" json:"with_check"`
}

// GetRLSPolicies retrieves all row level security policies
func (q *Queries) GetRLSPolicies(ctx context.Context) ([]GetRLSPoliciesRow, error) {
	rows, err := q.db.QueryContext(ctx, getRLSPolicies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRLSPoliciesRow
	for rows.Next() {
		var i GetRLSPoliciesRow
		if err := rows.Scan(
			&i.Schemaname,
			&i.Tablename,
			&i.Policyname,
			&i.Permissive,
			pq.Array(&i.Roles),
			&i.Cmd,
			&i.Qual,
			&i.WithCheck,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRLSPoliciesForSchema = `-- name: GetRLSPoliciesForSchema :many
SELECT 
    schemaname,
    tablename,
    policyname,
    permissive,
    roles,
    cmd,
    qual,
    with_check
FROM pg_policies
WHERE 
    schemaname = $1
ORDER BY schemaname, tablename, policyname
`

type GetRLSPoliciesForSchemaRow struct {
	Schemaname sql.NullString `db:"schemaname" json:"schemaname"`
	Tablename  sql.NullString `db:"tablename" json:"tablename"`
	Policyname sql.NullString `db:"policyname" json:"policyname"`
	Permissive sql.NullString `db:"permissive" json:"permissive"`
	Roles      []string       `db:"roles" json:"roles"`
	Cmd        sql.NullString `db:"cmd" json:"cmd"`
	Qual       sql.NullString `db:"qual" json:"qual"`
	WithCheck  sql.NullString `db:"with_check" json:"with_check"`
}

// GetRLSPoliciesForSchema retrieves all row level security policies for a specific schema
func (q *Queries) GetRLSPoliciesForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetRLSPoliciesForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getRLSPoliciesForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRLSPoliciesForSchemaRow
	for rows.Next() {
		var i GetRLSPoliciesForSchemaRow
		if err := rows.Scan(
			&i.Schemaname,
			&i.Tablename,
			&i.Policyname,
			&i.Permissive,
			pq.Array(&i.Roles),
			&i.Cmd,
			&i.Qual,
			&i.WithCheck,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRLSTables = `-- name: GetRLSTables :many
SELECT
    n.nspname AS schemaname,
    c.relname AS tablename,
    c.relrowsecurity AS rowsecurity,
    c.relforcerowsecurity AS rowforced
FROM pg_catalog.pg_class c
JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
WHERE
    n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
    AND c.relkind = 'r'
    AND c.relrowsecurity = true
ORDER BY n.nspname, c.relname
`

type GetRLSTablesRow struct {
	Schemaname  string `db:"schemaname" json:"schemaname"`
	Tablename   string `db:"tablename" json:"tablename"`
	Rowsecurity bool   `db:"rowsecurity" json:"rowsecurity"`
	Rowforced   bool   `db:"rowforced" json:"rowforced"`
}

// GetRLSTables retrieves tables with row level security enabled
func (q *Queries) GetRLSTables(ctx context.Context) ([]GetRLSTablesRow, error) {
	rows, err := q.db.QueryContext(ctx, getRLSTables)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRLSTablesRow
	for rows.Next() {
		var i GetRLSTablesRow
		if err := rows.Scan(
			&i.Schemaname,
			&i.Tablename,
			&i.Rowsecurity,
			&i.Rowforced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRLSTablesForSchema = `-- name: GetRLSTablesForSchema :many
SELECT
    n.nspname AS schemaname,
    c.relname AS tablename,
    c.relrowsecurity AS rowsecurity,
    c.relforcerowsecurity AS rowforced
FROM pg_catalog.pg_class c
JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
WHERE
    n.nspname = $1
    AND c.relkind = 'r'
    AND c.relrowsecurity = true
ORDER BY n.nspname, c.relname
`

type GetRLSTablesForSchemaRow struct {
	Schemaname  string `db:"schemaname" json:"schemaname"`
	Tablename   string `db:"tablename" json:"tablename"`
	Rowsecurity bool   `db:"rowsecurity" json:"rowsecurity"`
	Rowforced   bool   `db:"rowforced" json:"rowforced"`
}

// GetRLSTablesForSchema retrieves tables with row level security enabled for a specific schema
func (q *Queries) GetRLSTablesForSchema(ctx context.Context, nspname string) ([]GetRLSTablesForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getRLSTablesForSchema, nspname)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRLSTablesForSchemaRow
	for rows.Next() {
		var i GetRLSTablesForSchemaRow
		if err := rows.Scan(
			&i.Schemaname,
			&i.Tablename,
			&i.Rowsecurity,
			&i.Rowforced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevokedDefaultPrivilegesForSchema = `-- name: GetRevokedDefaultPrivilegesForSchema :many
WITH objects_with_acl AS (
    -- Functions (ACL may be NULL for default permissions; filtering happens in public_grants CTE)
    SELECT
        p.proname || '(' || pg_get_function_identity_arguments(p.oid) || ')' AS object_name,
        'FUNCTION' AS object_type,
        p.proacl AS acl
    FROM pg_proc p
    JOIN pg_namespace n ON p.pronamespace = n.oid
    WHERE n.nspname = $1
        AND p.prokind = 'f'

    UNION ALL

    -- Procedures
    SELECT
        p.proname || '(' || pg_get_function_identity_arguments(p.oid) || ')' AS object_name,
        'PROCEDURE' AS object_type,
        p.proacl AS acl
    FROM pg_proc p
    JOIN pg_namespace n ON p.pronamespace = n.oid
    WHERE n.nspname = $1
        AND p.prokind = 'p'

    UNION ALL

    -- Types
    SELECT
        t.typname::text AS object_name,
        'TYPE' AS object_type,
        t.typacl AS acl
    FROM pg_type t
    JOIN pg_namespace n ON t.typnamespace = n.oid
    WHERE n.nspname = $1
        AND t.typtype IN ('e', 'c', 'd')
),
public_grants AS (
    SELECT
        object_name,
        object_type,
        EXISTS (
            SELECT 1
            FROM unnest(acl) AS acl_entry
            WHERE acl_entry::text LIKE '=%'  -- PUBLIC grants start with =
        ) AS has_public_grant,
        acl IS NOT NULL AS has_explicit_acl
    FROM objects_with_acl
)
SELECT object_name, object_type
FROM public_grants
WHERE has_explicit_acl = true AND has_public_grant = false
ORDER BY object_type, object_name
`

type GetRevokedDefaultPrivilegesForSchemaRow struct {
	ObjectName sql.NullString `db:"object_name" json:"object_name"`
	ObjectType sql.NullString `db:"object_type" json:"object_type"`
}

// GetRevokedDefaultPrivilegesForSchema finds objects where default PUBLIC grants have been explicitly revoked
func (q *Queries) GetRevokedDefaultPrivilegesForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetRevokedDefaultPrivilegesForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevokedDefaultPrivilegesForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevokedDefaultPrivilegesForSchemaRow
	for rows.Next() {
		var i GetRevokedDefaultPrivilegesForSchemaRow
		if err := rows.Scan(&i.ObjectName, &i.ObjectType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchema = `-- name: GetSchema :one
SELECT 
    schema_name
FROM information_schema.schemata
WHERE 
    schema_name = $1
    AND schema_name NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND schema_name NOT LIKE 'pg_temp_%'
    AND schema_name NOT LIKE 'pg_toast_temp_%'
`

// GetSchema retrieves a specific schema by name
func (q *Queries) GetSchema(ctx context.Context, schemaName sql.NullString) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getSchema, schemaName)
	var schema_name interface{}
	err := row.Scan(&schema_name)
	return schema_name, err
}

const getSchemas = `-- name: GetSchemas :many
SELECT 
    schema_name
FROM information_schema.schemata
WHERE 
    schema_name NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND schema_name NOT LIKE 'pg_temp_%'
    AND schema_name NOT LIKE 'pg_toast_temp_%'
ORDER BY schema_name
`

// GetSchemas retrieves all user-defined schemas
func (q *Queries) GetSchemas(ctx context.Context) ([]interface{}, error) {
	rows, err := q.db.QueryContext(ctx, getSchemas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var schema_name interface{}
		if err := rows.Scan(&schema_name); err != nil {
			return nil, err
		}
		items = append(items, schema_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSequences = `-- name: GetSequences :many
SELECT 
    sequence_schema,
    sequence_name,
    data_type,
    start_value,
    minimum_value,
    maximum_value,
    increment,
    cycle_option
FROM information_schema.sequences
WHERE 
    sequence_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND sequence_schema NOT LIKE 'pg_temp_%'
    AND sequence_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY sequence_schema, sequence_name
`

type GetSequencesRow struct {
	SequenceSchema interface{} `db:"sequence_schema" json:"sequence_schema"`
	SequenceName   interface{} `db:"sequence_name" json:"sequence_name"`
	DataType       interface{} `db:"data_type" json:"data_type"`
	StartValue     interface{} `db:"start_value" json:"start_value"`
	MinimumValue   interface{} `db:"minimum_value" json:"minimum_value"`
	MaximumValue   interface{} `db:"maximum_value" json:"maximum_value"`
	Increment      interface{} `db:"increment" json:"increment"`
	CycleOption    interface{} `db:"cycle_option" json:"cycle_option"`
}

// GetSequences retrieves all sequences
func (q *Queries) GetSequences(ctx context.Context) ([]GetSequencesRow, error) {
	rows, err := q.db.QueryContext(ctx, getSequences)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSequencesRow
	for rows.Next() {
		var i GetSequencesRow
		if err := rows.Scan(
			&i.SequenceSchema,
			&i.SequenceName,
			&i.DataType,
			&i.StartValue,
			&i.MinimumValue,
			&i.MaximumValue,
			&i.Increment,
			&i.CycleOption,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSequencesForSchema = `-- name: GetSequencesForSchema :many
SELECT 
    s.schemaname AS sequence_schema,
    s.sequencename AS sequence_name,
    s.data_type,
    s.start_value,
    s.min_value AS minimum_value,
    s.max_value AS maximum_value,
    s.increment_by AS increment,
    s.cycle AS cycle_option,
    s.cache_size,
    COALESCE(dep_table.relname, col_table.table_name) AS owned_by_table,
    COALESCE(dep_col.attname, col_table.column_name) AS owned_by_column
FROM pg_sequences s
LEFT JOIN pg_namespace n ON n.nspname = s.schemaname
LEFT JOIN pg_class c ON c.relname = s.sequencename AND c.relnamespace = n.oid
LEFT JOIN pg_depend d ON d.objid = c.oid AND d.classid = 'pg_class'::regclass AND d.deptype IN ('a', 'i')
LEFT JOIN pg_class dep_table ON d.refobjid = dep_table.oid
LEFT JOIN pg_attribute dep_col ON dep_col.attrelid = dep_table.oid AND dep_col.attnum = d.refobjsubid
LEFT JOIN (
    SELECT 
        col.table_name,
        col.column_name,
        REGEXP_REPLACE(
            REGEXP_REPLACE(col.column_default, 'nextval\(''([^'']+)''.*\)', '\1'),
            '^[^.]*\.', ''
        ) AS sequence_name
    FROM information_schema.columns col
    WHERE col.table_schema = $1
      AND col.column_default LIKE '%nextval%'
) col_table ON col_table.sequence_name = s.sequencename
WHERE s.schemaname = $1
ORDER BY s.schemaname, s.sequencename
`

type GetSequencesForSchemaRow struct {
	SequenceSchema sql.NullString `db:"sequence_schema" json:"sequence_schema"`
	SequenceName   sql.NullString `db:"sequence_name" json:"sequence_name"`
	DataType       interface{}    `db:"data_type" json:"data_type"`
	StartValue     sql.NullInt64  `db:"start_value" json:"start_value"`
	MinimumValue   sql.NullInt64  `db:"minimum_value" json:"minimum_value"`
	MaximumValue   sql.NullInt64  `db:"maximum_value" json:"maximum_value"`
	Increment      sql.NullInt64  `db:"increment" json:"increment"`
	CycleOption    sql.NullBool   `db:"cycle_option" json:"cycle_option"`
	CacheSize      sql.NullInt64  `db:"cache_size" json:"cache_size"`
	OwnedByTable   sql.NullString `db:"owned_by_table" json:"owned_by_table"`
	OwnedByColumn  sql.NullString `db:"owned_by_column" json:"owned_by_column"`
}

// GetSequencesForSchema retrieves all sequences for a specific schema
// Method 1: Try to find dependency relationship (for proper SERIAL columns)
// Method 2: Find sequences used in column defaults (for nextval() patterns)
func (q *Queries) GetSequencesForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetSequencesForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getSequencesForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSequencesForSchemaRow
	for rows.Next() {
		var i GetSequencesForSchemaRow
		if err := rows.Scan(
			&i.SequenceSchema,
			&i.SequenceName,
			&i.DataType,
			&i.StartValue,
			&i.MinimumValue,
			&i.MaximumValue,
			&i.Increment,
			&i.CycleOption,
			&i.CacheSize,
			&i.OwnedByTable,
			&i.OwnedByColumn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTables = `-- name: GetTables :many
SELECT 
    t.table_schema,
    t.table_name,
    t.table_type,
    COALESCE(d.description, '') AS table_comment
FROM information_schema.tables t
LEFT JOIN pg_namespace n ON n.nspname = t.table_schema
LEFT JOIN pg_class c ON c.relname = t.table_name AND c.relnamespace = n.oid
LEFT JOIN pg_description d ON d.objoid = c.oid AND d.classoid = 'pg_class'::regclass AND d.objsubid = 0
WHERE
    t.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND t.table_schema NOT LIKE 'pg_temp_%'
    AND t.table_schema NOT LIKE 'pg_toast_temp_%'
    AND t.table_type IN ('BASE TABLE', 'VIEW')
ORDER BY t.table_schema, t.table_name
`

type GetTablesRow struct {
	TableSchema  interface{}    `db:"table_schema" json:"table_schema"`
	TableName    interface{}    `db:"table_name" json:"table_name"`
	TableType    interface{}    `db:"table_type" json:"table_type"`
	TableComment sql.NullString `db:"table_comment" json:"table_comment"`
}

// GetTables retrieves all tables in the database with metadata
func (q *Queries) GetTables(ctx context.Context) ([]GetTablesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTables)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTablesRow
	for rows.Next() {
		var i GetTablesRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.TableType,
			&i.TableComment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTablesForSchema = `-- name: GetTablesForSchema :many
SELECT 
    t.table_schema,
    t.table_name,
    t.table_type,
    COALESCE(d.description, '') AS table_comment
FROM information_schema.tables t
LEFT JOIN pg_namespace n ON n.nspname = t.table_schema
LEFT JOIN pg_class c ON c.relname = t.table_name AND c.relnamespace = n.oid
LEFT JOIN pg_description d ON d.objoid = c.oid AND d.classoid = 'pg_class'::regclass AND d.objsubid = 0
WHERE
    t.table_schema = $1
    AND t.table_type IN ('BASE TABLE', 'VIEW')
ORDER BY t.table_name
`

type GetTablesForSchemaRow struct {
	TableSchema  interface{}    `db:"table_schema" json:"table_schema"`
	TableName    interface{}    `db:"table_name" json:"table_name"`
	TableType    interface{}    `db:"table_type" json:"table_type"`
	TableComment sql.NullString `db:"table_comment" json:"table_comment"`
}

// GetTablesForSchema retrieves all tables in a specific schema with metadata
func (q *Queries) GetTablesForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetTablesForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getTablesForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTablesForSchemaRow
	for rows.Next() {
		var i GetTablesForSchemaRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.TableType,
			&i.TableComment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTriggers = `-- name: GetTriggers :many
SELECT 
    trigger_schema,
    trigger_name,
    event_object_table,
    action_timing,
    event_manipulation,
    action_statement,
    action_condition,
    action_orientation
FROM information_schema.triggers
WHERE 
    trigger_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND trigger_schema NOT LIKE 'pg_temp_%'
    AND trigger_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY trigger_schema, event_object_table, trigger_name
`

type GetTriggersRow struct {
	TriggerSchema     interface{} `db:"trigger_schema" json:"trigger_schema"`
	TriggerName       interface{} `db:"trigger_name" json:"trigger_name"`
	EventObjectTable  interface{} `db:"event_object_table" json:"event_object_table"`
	ActionTiming      interface{} `db:"action_timing" json:"action_timing"`
	EventManipulation interface{} `db:"event_manipulation" json:"event_manipulation"`
	ActionStatement   interface{} `db:"action_statement" json:"action_statement"`
	ActionCondition   interface{} `db:"action_condition" json:"action_condition"`
	ActionOrientation interface{} `db:"action_orientation" json:"action_orientation"`
}

// GetTriggers retrieves all triggers
func (q *Queries) GetTriggers(ctx context.Context) ([]GetTriggersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTriggers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTriggersRow
	for rows.Next() {
		var i GetTriggersRow
		if err := rows.Scan(
			&i.TriggerSchema,
			&i.TriggerName,
			&i.EventObjectTable,
			&i.ActionTiming,
			&i.EventManipulation,
			&i.ActionStatement,
			&i.ActionCondition,
			&i.ActionOrientation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTriggersForSchema = `-- name: GetTriggersForSchema :many
SELECT
    n.nspname AS trigger_schema,
    c.relname AS event_object_table,
    t.tgname AS trigger_name,
    t.tgtype AS trigger_type,
    t.tgenabled AS trigger_enabled,
    t.tgdeferrable AS trigger_deferrable,
    t.tginitdeferred AS trigger_initdeferred,
    t.tgconstraint AS trigger_constraint_oid,
    COALESCE(pg_catalog.pg_get_triggerdef(t.oid), '') AS trigger_definition,
    COALESCE(t.tgoldtable, '') AS old_table,
    COALESCE(t.tgnewtable, '') AS new_table,
    p.proname AS function_name,
    pn.nspname AS function_schema,
    COALESCE(d.description, '') AS trigger_comment
FROM pg_catalog.pg_trigger t
JOIN pg_catalog.pg_class c ON t.tgrelid = c.oid
JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
JOIN pg_catalog.pg_proc p ON t.tgfoid = p.oid
JOIN pg_catalog.pg_namespace pn ON p.pronamespace = pn.oid
LEFT JOIN pg_description d ON d.objoid = t.oid AND d.classoid = 'pg_trigger'::regclass
WHERE n.nspname = $1
    AND NOT t.tgisinternal  -- Exclude internal triggers
ORDER BY n.nspname, c.relname, t.tgname
`

type GetTriggersForSchemaRow struct {
	TriggerSchema        string         `db:"trigger_schema" json:"trigger_schema"`
	EventObjectTable     string         `db:"event_object_table" json:"event_object_table"`
	TriggerName          string         `db:"trigger_name" json:"trigger_name"`
	TriggerType          int16          `db:"trigger_type" json:"trigger_type"`
	TriggerEnabled       interface{}    `db:"trigger_enabled" json:"trigger_enabled"`
	TriggerDeferrable    bool           `db:"trigger_deferrable" json:"trigger_deferrable"`
	TriggerInitdeferred  bool           `db:"trigger_initdeferred" json:"trigger_initdeferred"`
	TriggerConstraintOid interface{}    `db:"trigger_constraint_oid" json:"trigger_constraint_oid"`
	TriggerDefinition    sql.NullString `db:"trigger_definition" json:"trigger_definition"`
	OldTable             sql.NullString `db:"old_table" json:"old_table"`
	NewTable             sql.NullString `db:"new_table" json:"new_table"`
	FunctionName         string         `db:"function_name" json:"function_name"`
	FunctionSchema       string         `db:"function_schema" json:"function_schema"`
	TriggerComment       sql.NullString `db:"trigger_comment" json:"trigger_comment"`
}

// GetTriggersForSchema retrieves all triggers for a specific schema
// Uses pg_trigger catalog to include all trigger types (including TRUNCATE)
// which are not visible in information_schema.triggers
func (q *Queries) GetTriggersForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetTriggersForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getTriggersForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTriggersForSchemaRow
	for rows.Next() {
		var i GetTriggersForSchemaRow
		if err := rows.Scan(
			&i.TriggerSchema,
			&i.EventObjectTable,
			&i.TriggerName,
			&i.TriggerType,
			&i.TriggerEnabled,
			&i.TriggerDeferrable,
			&i.TriggerInitdeferred,
			&i.TriggerConstraintOid,
			&i.TriggerDefinition,
			&i.OldTable,
			&i.NewTable,
			&i.FunctionName,
			&i.FunctionSchema,
			&i.TriggerComment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypes = `-- name: GetTypes :many
SELECT 
    n.nspname AS type_schema,
    t.typname AS type_name,
    CASE t.typtype
        WHEN 'e' THEN 'ENUM'
        WHEN 'c' THEN 'COMPOSITE'
        ELSE 'OTHER'
    END AS type_kind,
    COALESCE(d.description, '') AS type_comment
FROM pg_type t
JOIN pg_namespace n ON t.typnamespace = n.oid
LEFT JOIN pg_description d ON d.objoid = t.oid AND d.classoid = 'pg_type'::regclass
LEFT JOIN pg_class c ON t.typrelid = c.oid
WHERE t.typtype IN ('e', 'c')  -- ENUM and composite types only
    AND n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
    AND (t.typtype = 'e' OR (t.typtype = 'c' AND c.relkind = 'c'))  -- For composite types, only include true composite types (not table types)
ORDER BY n.nspname, t.typname
`

type GetTypesRow struct {
	TypeSchema  string         `db:"type_schema" json:"type_schema"`
	TypeName    string         `db:"type_name" json:"type_name"`
	TypeKind    sql.NullString `db:"type_kind" json:"type_kind"`
	TypeComment sql.NullString `db:"type_comment" json:"type_comment"`
}

// GetTypes retrieves all user-defined types (ENUM and composite types)
func (q *Queries) GetTypes(ctx context.Context) ([]GetTypesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTypesRow
	for rows.Next() {
		var i GetTypesRow
		if err := rows.Scan(
			&i.TypeSchema,
			&i.TypeName,
			&i.TypeKind,
			&i.TypeComment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypesForSchema = `-- name: GetTypesForSchema :many
SELECT 
    n.nspname AS type_schema,
    t.typname AS type_name,
    CASE t.typtype
        WHEN 'e' THEN 'ENUM'
        WHEN 'c' THEN 'COMPOSITE'
        ELSE 'OTHER'
    END AS type_kind,
    COALESCE(d.description, '') AS type_comment
FROM pg_type t
JOIN pg_namespace n ON t.typnamespace = n.oid
LEFT JOIN pg_description d ON d.objoid = t.oid AND d.classoid = 'pg_type'::regclass
LEFT JOIN pg_class c ON t.typrelid = c.oid
WHERE t.typtype IN ('e', 'c')  -- ENUM and composite types only
    AND n.nspname = $1
    AND (t.typtype = 'e' OR (t.typtype = 'c' AND c.relkind = 'c'))  -- For composite types, only include true composite types (not table types)
ORDER BY n.nspname, t.typname
`

type GetTypesForSchemaRow struct {
	TypeSchema  string         `db:"type_schema" json:"type_schema"`
	TypeName    string         `db:"type_name" json:"type_name"`
	TypeKind    sql.NullString `db:"type_kind" json:"type_kind"`
	TypeComment sql.NullString `db:"type_comment" json:"type_comment"`
}

// GetTypesForSchema retrieves all user-defined types for a specific schema
func (q *Queries) GetTypesForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetTypesForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getTypesForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTypesForSchemaRow
	for rows.Next() {
		var i GetTypesForSchemaRow
		if err := rows.Scan(
			&i.TypeSchema,
			&i.TypeName,
			&i.TypeKind,
			&i.TypeComment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getViewDependencies = `-- name: GetViewDependencies :many
SELECT DISTINCT
    vtu.view_schema AS dependent_schema,
    vtu.view_name AS dependent_name,
    vtu.table_schema AS source_schema,
    vtu.table_name AS source_name
FROM information_schema.view_table_usage vtu
WHERE 
    vtu.view_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND vtu.view_schema NOT LIKE 'pg_temp_%'
    AND vtu.view_schema NOT LIKE 'pg_toast_temp_%'
    AND vtu.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND vtu.table_schema NOT LIKE 'pg_temp_%'
    AND vtu.table_schema NOT LIKE 'pg_toast_temp_%'
ORDER BY vtu.view_schema, vtu.view_name, vtu.table_schema, vtu.table_name
`

type GetViewDependenciesRow struct {
	DependentSchema interface{} `db:"dependent_schema" json:"dependent_schema"`
	DependentName   interface{} `db:"dependent_name" json:"dependent_name"`
	SourceSchema    interface{} `db:"source_schema" json:"source_schema"`
	SourceName      interface{} `db:"source_name" json:"source_name"`
}

// GetViewDependencies retrieves view dependencies on tables and other views
func (q *Queries) GetViewDependencies(ctx context.Context) ([]GetViewDependenciesRow, error) {
	rows, err := q.db.QueryContext(ctx, getViewDependencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetViewDependenciesRow
	for rows.Next() {
		var i GetViewDependenciesRow
		if err := rows.Scan(
			&i.DependentSchema,
			&i.DependentName,
			&i.SourceSchema,
			&i.SourceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getViews = `-- name: GetViews :many
SELECT 
    n.nspname AS table_schema,
    c.relname AS table_name,
    pg_get_viewdef(c.oid, true) AS view_definition,
    COALESCE(d.description, '') AS view_comment,
    (c.relkind = 'm') AS is_materialized
FROM pg_class c
JOIN pg_namespace n ON c.relnamespace = n.oid
LEFT JOIN pg_description d ON d.objoid = c.oid AND d.classoid = 'pg_class'::regclass AND d.objsubid = 0
WHERE 
    c.relkind IN ('v', 'm') -- views and materialized views
    AND n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
    AND n.nspname NOT LIKE 'pg_temp_%'
    AND n.nspname NOT LIKE 'pg_toast_temp_%'
ORDER BY n.nspname, c.relname
`

type GetViewsRow struct {
	TableSchema    string         `db:"table_schema" json:"table_schema"`
	TableName      string         `db:"table_name" json:"table_name"`
	ViewDefinition sql.NullString `db:"view_definition" json:"view_definition"`
	ViewComment    sql.NullString `db:"view_comment" json:"view_comment"`
	IsMaterialized sql.NullBool   `db:"is_materialized" json:"is_materialized"`
}

// GetViews retrieves all views and materialized views
func (q *Queries) GetViews(ctx context.Context) ([]GetViewsRow, error) {
	rows, err := q.db.QueryContext(ctx, getViews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetViewsRow
	for rows.Next() {
		var i GetViewsRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.ViewDefinition,
			&i.ViewComment,
			&i.IsMaterialized,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getViewsForSchema = `-- name: GetViewsForSchema :many
WITH view_definitions AS (
    SELECT
        n.nspname AS table_schema,
        c.relname AS table_name,
        c.oid AS view_oid,
        COALESCE(d.description, '') AS view_comment,
        (c.relkind = 'm') AS is_materialized,
        n.nspname AS view_schema
    FROM pg_class c
    JOIN pg_namespace n ON c.relnamespace = n.oid
    LEFT JOIN pg_description d ON d.objoid = c.oid AND d.classoid = 'pg_class'::regclass AND d.objsubid = 0
    WHERE
        c.relkind IN ('v', 'm') -- views and materialized views
        AND n.nspname = $1
)
SELECT
    vd.table_schema,
    vd.table_name,
    -- Use LATERAL join to guarantee execution order:
    -- 1. set_config sets search_path to only the view's schema
    -- 2. pg_get_viewdef then uses that search_path
    -- This ensures cross-schema table references are qualified with schema names
    sp.view_def AS view_definition,
    vd.view_comment,
    vd.is_materialized
FROM view_definitions vd
CROSS JOIN LATERAL (
    SELECT
        set_config('search_path', vd.view_schema || ', pg_catalog', true) as dummy,
        pg_get_viewdef(vd.view_oid, true) as view_def
) sp
ORDER BY vd.table_schema, vd.table_name
`

type GetViewsForSchemaRow struct {
	TableSchema    string         `db:"table_schema" json:"table_schema"`
	TableName      string         `db:"table_name" json:"table_name"`
	ViewDefinition sql.NullString `db:"view_definition" json:"view_definition"`
	ViewComment    sql.NullString `db:"view_comment" json:"view_comment"`
	IsMaterialized sql.NullBool   `db:"is_materialized" json:"is_materialized"`
}

// GetViewsForSchema retrieves all views and materialized views for a specific schema
// IMPORTANT: Uses LATERAL join with set_config to temporarily set search_path to only the view's schema
// This ensures pg_get_viewdef() includes schema qualifiers for cross-schema references
// The LATERAL join guarantees set_config executes before pg_get_viewdef in the same row context
func (q *Queries) GetViewsForSchema(ctx context.Context, dollar_1 sql.NullString) ([]GetViewsForSchemaRow, error) {
	rows, err := q.db.QueryContext(ctx, getViewsForSchema, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetViewsForSchemaRow
	for rows.Next() {
		var i GetViewsForSchemaRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.ViewDefinition,
			&i.ViewComment,
			&i.IsMaterialized,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFunctionDependencies = `-- name: GetFunctionDependencies :many
SELECT
    dependent_ns.nspname AS dependent_schema,
    dependent_proc.proname AS dependent_name,
    pg_get_function_identity_arguments(dependent_proc.oid) AS dependent_args,
    referenced_ns.nspname AS referenced_schema,
    referenced_proc.proname AS referenced_name,
    pg_get_function_identity_arguments(referenced_proc.oid) AS referenced_args
FROM pg_depend d
JOIN pg_proc dependent_proc ON d.objid = dependent_proc.oid
JOIN pg_namespace dependent_ns ON dependent_proc.pronamespace = dependent_ns.oid
JOIN pg_proc referenced_proc ON d.refobjid = referenced_proc.oid
JOIN pg_namespace referenced_ns ON referenced_proc.pronamespace = referenced_ns.oid
WHERE d.classid = 'pg_proc'::regclass
  AND d.refclassid = 'pg_proc'::regclass
  AND d.deptype = 'n'
  AND dependent_ns.nspname = $1
`

type GetFunctionDependenciesRow struct {
	DependentSchema  string         `db:"dependent_schema" json:"dependent_schema"`
	DependentName    string         `db:"dependent_name" json:"dependent_name"`
	DependentArgs    sql.NullString `db:"dependent_args" json:"dependent_args"`
	ReferencedSchema string         `db:"referenced_schema" json:"referenced_schema"`
	ReferencedName   string         `db:"referenced_name" json:"referenced_name"`
	ReferencedArgs   sql.NullString `db:"referenced_args" json:"referenced_args"`
}

// GetFunctionDependencies retrieves function-to-function dependencies for topological sorting
func (q *Queries) GetFunctionDependencies(ctx context.Context, dollar_1 sql.NullString) ([]GetFunctionDependenciesRow, error) {
	rows, err := q.db.QueryContext(ctx, getFunctionDependencies, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFunctionDependenciesRow
	for rows.Next() {
		var i GetFunctionDependenciesRow
		if err := rows.Scan(
			&i.DependentSchema,
			&i.DependentName,
			&i.DependentArgs,
			&i.ReferencedSchema,
			&i.ReferencedName,
			&i.ReferencedArgs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
